## 第一部分：系统哲学与核心理解

### 1.1 这个系统在模拟什么？

我们在模拟的不是"数据库"，而是**多个独立意识体共存于同一世界的认知过程**。

想象一个真实的TRPG桌游：

- **GM**坐在屏风后面，知道所有剧情线、所有NPC的真实动机、所有玩家不知道的阴谋
- **每个NPC**在GM脑中是一个"人格切片"——GM扮演他们时，要假装"忘记"那些这个NPC不应该知道的信息
- **信息通过对话传递**——Marcus要亲口告诉Gorn，Gorn才能知道森林里发生了什么

我们的系统就是要把这个过程**外化、持久化、自动化**。GM不再需要"假装忘记"，因为每个NPC真的只能访问属于自己的记忆图谱。

### 1.2 为什么是图而不是文档？

人类记忆不是线性的文档，而是**关联的网络**。

当你听到"苹果"这个词：

- 可能想到水果 → 红色 → 健康
- 可能想到公司 → iPhone → 乔布斯
- 可能想到你奶奶家的苹果树 → 童年 → 夏天

哪条路径被激活，取决于**当前上下文**。这就是激活扩散的本质——从触发点出发，能量沿着关联路径传播，最终浮现出"相关"的记忆。

图结构天然支持这种多路径、多跳跃的联想检索。

### 1.3 双层认知的必要性

**为什么不能只用一个LLM？**

因为128K的上下文窗口放不下一个角色的全部人生。即使能放下，每次对话都处理全部记忆也是浪费。

人类也是这样工作的：

- **工作记忆**（Pro）：容量有限，只处理当下最相关的信息
- **长期记忆**（Flash + 图谱）：容量巨大，但需要"检索"才能进入意识

Flash的角色就像是"潜意识的图书管理员"——Pro说"我需要关于侄子的信息"，Flash就去图谱里找，找到后翻译成Pro能直接用的形式。

---

## 第二部分：数据架构

### 2.1 三类图谱的定位

```
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                         │
│    世界观图谱 (Ontology)          GM图谱 (God's Eye)                     │
│    ════════════════════          ══════════════════                     │
│    "世界是什么样的"               "世界发生了什么"                        │
│                                                                         │
│    • 地理结构                     • 全部事件（含未被目击的）               │
│    • 种族/职业/阵营               • 所有角色的真实位置                    │
│    • 组织/派系                    • 剧情线的真实状态                      │
│    • 规则/机制                    • 隐藏的阴谋                           │
│    • 怪物/物品百科                • 玩家行为的全部记录                    │
│                                                                         │
│    只读 / 所有人共享引用           只有GM可读写                           │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    │ 事件分发（按"谁知道"过滤）
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                         角色记忆图谱 (Per-Character)                     │
│                         ═══════════════════════════                     │
│                         "我经历了什么 / 我知道什么"                       │
│                                                                         │
│    每个NPC独立拥有一份：                                                  │
│    • 我认识的人（以及我对他们的看法）                                      │
│    • 我经历的事件（一手）                                                 │
│    • 我听说的事情（二手，有可信度标记）                                    │
│    • 我的知识（职业技能、本地知识等）                                      │
│    • 我的情感状态                                                        │
│    • 我当前的目标和计划                                                   │
│                                                                         │
│    可读写 / 只有这个角色的Flash可以访问                                   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘

```

### 2.2 节点设计

**节点是图谱的基本单位，代表一个"概念"或"实体"。**

```yaml
# 通用节点结构
Node:
  id: string           # 唯一标识符
  type: NodeType       # 节点类型（见下）
  name: string         # 显示名称
  created_at: datetime # 创建时间
  updated_at: datetime # 最后更新
  importance: float    # 重要度 0-1，影响激活扩散
  properties: dict     # 类型特定的属性

```

**节点类型与属性：**

| 类型 | 用途 | 关键属性 |
| --- | --- | --- |
| `identity` | 角色自我认知（每个记忆图谱有且仅有一个） | personality, goals, fears |
| `person` | 认识的人 | relation, trust_level, last_seen |
| `location` | 知道的地点 | visited, familiarity |
| `event` | 经历/目击的事件 | day, summary, emotion, participants |
| `rumor` | 听说的传闻 | source, reliability, content |
| `knowledge` | 掌握的知识/技能 | domain, proficiency |
| `item` | 拥有/知道的物品 | possession_status, value |
| `goal` | 当前目标 | priority, progress, deadline |
| `emotion` | 情感状态 | target, intensity, cause |

### 2.3 边设计

**边代表节点之间的关系，是激活扩散的路径。**

```yaml
# 边结构
Edge:
  id: string
  source: string       # 起点节点ID
  target: string       # 终点节点ID
  relation: RelationType
  weight: float        # 关联强度 0-1
  created_at: datetime
  properties: dict

```

**关系类型：**

| 类别 | 关系 | 说明 |
| --- | --- | --- |
| **事实关系** | `located_in`, `part_of`, `owns`, `works_at` | 客观存在的关系 |
| **社会关系** | `family`, `friend`, `enemy`, `colleague`, `knows` | 人际关系 |
| **事件关联** | `participated`, `witnessed`, `heard_about`, `caused` | 事件与实体的关联 |
| **认知关系** | `believes`, `suspects`, `knows_that` | 主观认知 |
| **情感关系** | `likes`, `fears`, `trusts`, `hates` | 情感指向 |
| **引用关系** | `refers_to` | 指向世界观图谱的引用 |

### 2.4 引用机制

角色记忆图谱不复制世界观数据，而是**引用**：

```
角色图谱中：
  Node(id="ref:eastern_forest", type="location_ref",
       target_graph="ontology", target_id="eastern_forest")

查询时：
  1. 发现是引用节点
  2. 去世界观图谱获取完整信息
  3. 合并后返回

```

这样的好处：

- 世界观更新时，所有引用自动获得最新信息
- 节省存储空间
- 保持一致性

### 2.5 Firestore 数据结构

```
firestore/
├── worlds/{world_id}/
│   ├── meta                     # 世界元数据
│   │   └── {name, created_at, settings}
│   │
│   ├── ontology/                # 世界观图谱
│   │   ├── nodes/{node_id}
│   │   │   └── {type, name, properties, ...}
│   │   └── edges/{edge_id}
│   │       └── {source, target, relation, weight, ...}
│   │
│   ├── gm/                      # GM全局图谱
│   │   ├── nodes/{node_id}
│   │   ├── edges/{edge_id}
│   │   └── timeline/            # 时间线索引
│   │       └── {day_1, day_2, ...}  # 按天索引事件
│   │
│   └── characters/{char_id}/    # 角色记忆图谱
│       ├── profile              # 角色基础配置
│       │   └── {name, system_prompt, personality}
│       ├── nodes/{node_id}
│       ├── edges/{edge_id}
│       └── state                # 运行时状态
│           └── {current_location, mood, active_goals}
│
└── sessions/{session_id}/       # 游戏会话
    ├── meta                     # 会话元数据
    ├── current_scene            # 当前场景
    ├── participants             # 在场角色列表
    └── event_log/               # 会话事件日志
        └── {seq_1, seq_2, ...}

```

---

## 第三部分：算法层

### 3.1 激活扩散算法

这是整个记忆检索的核心。完全用程序实现，不依赖LLM。

**算法伪代码：**

```
function spread_activation(graph, seeds, config):
    # 初始化
    activation = {node: 0.0 for node in graph.nodes}
    for seed in seeds:
        activation[seed] = 1.0

    # 迭代传播
    for iteration in range(config.max_iterations):
        new_activation = activation.copy()

        for node in graph.nodes:
            if activation[node] < config.fire_threshold:
                continue  # 未激活的节点不传播

            for neighbor, edge in graph.neighbors(node):
                # 计算传入信号
                signal = activation[node] * edge.weight * config.decay

                # 侧向抑制：高度连接的节点衰减
                if graph.degree(node) > config.hub_threshold:
                    signal *= config.hub_penalty

                # 累积激活（有上限）
                new_activation[neighbor] = min(
                    new_activation[neighbor] + signal,
                    config.max_activation
                )

        # 检查收敛
        if converged(activation, new_activation):
            break
        activation = new_activation

    # 返回超过阈值的节点
    return {node: act for node, act in activation.items()
            if act > config.output_threshold}

```

**关键参数：**

| 参数 | 默认值 | 说明 |
| --- | --- | --- |
| `max_iterations` | 3 | 最大传播轮数 |
| `decay` | 0.6 | 每跳衰减系数 |
| `fire_threshold` | 0.1 | 激活才能传播的最低值 |
| `output_threshold` | 0.15 | 返回结果的最低激活值 |
| `hub_threshold` | 20 | 被视为"中心节点"的连接数 |
| `hub_penalty` | 0.5 | 中心节点的输出衰减 |
| `max_activation` | 1.0 | 激活值上限 |

### 3.2 子图提取

激活扩散后，需要提取相关的子图供Flash翻译：

```
function extract_subgraph(graph, activated_nodes):
    subgraph = new Graph()

    # 添加激活的节点
    for node_id, activation in activated_nodes:
        node = graph.get_node(node_id)
        subgraph.add_node(node, activation=activation)

    # 添加连接这些节点的边
    for edge in graph.edges:
        if edge.source in activated_nodes and edge.target in activated_nodes:
            subgraph.add_edge(edge)

    # 解析引用节点，获取世界观信息
    for node in subgraph.nodes:
        if node.type.endswith("_ref"):
            enriched = resolve_reference(node)
            subgraph.update_node(node.id, enriched)

    return subgraph

```

### 3.3 路径重建

对于"A和B有什么关系"这类查询，需要找到连接路径：

```
function find_paths(graph, source, target, max_depth=4):
    paths = []

    def dfs(current, target, path, depth):
        if current == target:
            paths.append(path.copy())
            return
        if depth >= max_depth:
            return

        for neighbor, edge in graph.neighbors(current):
            if neighbor not in path:
                path.append((edge, neighbor))
                dfs(neighbor, target, path, depth + 1)
                path.pop()

    dfs(source, target, [], 0)

    # 按路径总权重排序
    paths.sort(key=lambda p: sum(e.weight for e, _ in p), reverse=True)
    return paths[:5]  # 返回最强的5条路径

```

---

## 第四部分：LLM层（Flash的职责）

### 4.1 Flash的三个核心任务

```
┌─────────────────────────────────────────────────────────────────┐
│                        Flash 的工作模式                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  任务1: 事件摄入 (Event Ingestion)                               │
│  ────────────────────────────────                               │
│  触发: 收到事件通知                                              │
│  输入: 事件的自然语言描述                                        │
│  输出: 结构化的节点和边                                          │
│  目的: 把发生的事情"记住"                                        │
│                                                                 │
│  任务2: 查询理解 (Query Understanding)                          │
│  ────────────────────────────────                               │
│  触发: Pro请求记忆                                               │
│  输入: 对话上下文 + Pro的请求                                    │
│  输出: 种子节点列表 + 检索意图                                   │
│  目的: 理解"需要想起什么"                                        │
│                                                                 │
│  任务3: 记忆翻译 (Memory Translation)                           │
│  ────────────────────────────────                               │
│  触发: 激活扩散完成后                                            │
│  输入: 激活的子图（结构化数据）                                   │
│  输出: 角色视角的自然语言描述                                     │
│  目的: 把图谱数据变成Pro能用的"回忆"                             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

```

### 4.2 事件摄入的Prompt设计

```markdown
# 角色: 记忆编码器

你是{character_name}的潜意识记忆系统。你的任务是将发生的事件编码为结构化的记忆节点和关系。

## 当前角色信息
- 名字: {name}
- 职业: {occupation}
- 性格: {personality}

## 已有的重要节点（供引用）
{existing_important_nodes}

## 需要编码的事件
{event_description}

## 输出要求

请分析这个事件，输出JSON格式的记忆结构：

```json
{
  "new_nodes": [
    {
      "id": "event_{timestamp}",
      "type": "event",
      "name": "简短的事件名",
      "properties": {
        "day": 当前游戏日,
        "summary": "从我的视角描述这件事（第一人称）",
        "emotion": "我对此的情绪反应",
        "importance": 0.0-1.0
      }
    }
  ],
  "new_edges": [
    {
      "source": "节点ID",
      "target": "节点ID",
      "relation": "关系类型",
      "weight": 0.0-1.0
    }
  ],
  "state_updates": {
    "mood": "如果情绪有变化",
    "goals": ["如果目标有变化"]
  }
}

```

## 编码原则

1. 只记录我能感知到的信息（在场/被告知）
2. 用第一人称视角描述
3. 包含情绪反应（这是我的记忆，不是客观记录）
4. 与已有节点建立合理的连接
5. 重要度基于这件事对我的影响程度

```

### 4.3 查询理解的Prompt设计

```markdown
# 角色: 记忆检索引导器

你是{character_name}的潜意识。当意识层需要回忆某些事情时，你负责理解需要检索什么。

## 当前对话上下文
{recent_conversation}

## 意识层的请求
"{query_from_pro}"

## 你的图谱中存在的主要节点类型
- 人物: {list_of_person_nodes}
- 地点: {list_of_location_nodes}
- 近期事件: {list_of_recent_events}

## 输出要求

```json
{
  "seed_nodes": ["node_id_1", "node_id_2"],
  "search_intent": "描述检索意图",
  "expected_depth": 2,  // 需要多少跳关联
  "filters": {
    "time_range": "recent/all",
    "emotion": "如果需要特定情绪的记忆",
    "related_to": "如果需要与特定人/事相关"
  }
}

```

## 分析要点

1. 对话中提到了什么实体？映射到已有节点
2. 是在问事实还是感受？
3. 需要多深的关联？（直接记忆 vs 推理出的关联）

```

### 4.4 记忆翻译的Prompt设计

```markdown
# 角色: 记忆叙述者

你是{character_name}。以下是你刚刚"想起来"的记忆片段，请用第一人称、符合你性格的方式复述出来。

## 你的性格
{personality_description}

## 激活的记忆网络
{activated_subgraph_description}

## 激活路径
从 "{seed}" 联想到:
1. {path_1}
2. {path_2}
...

## 输出要求

用自然的方式描述你想起了什么。要求：
1. 第一人称
2. 符合你的说话风格
3. 按激活强度排序（最相关的先说）
4. 情感色彩要体现出来
5. 不要像在读报告，要像在回忆

## 输出格式
直接输出叙述文本，不需要JSON。这段文字会被直接注入到你的意识中。

```

---

## 第五部分：事件总线与通信

### 5.1 事件的生命周期

```
┌──────────────────────────────────────────────────────────────────────────┐
│                           事件生命周期                                    │
├──────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  1. 事件发生                                                              │
│     ├── 玩家行动触发                                                      │
│     ├── NPC自主行动触发                                                   │
│     ├── 系统事件（时间流逝、环境变化）                                      │
│     └── 战斗结果触发                                                      │
│                        │                                                 │
│                        ▼                                                 │
│  2. GM Flash 记录                                                        │
│     ├── 写入GM全局图谱                                                    │
│     ├── 标记事件属性（位置、参与者、可见性）                                │
│     └── 决定分发策略                                                      │
│                        │                                                 │
│                        ▼                                                 │
│  3. 事件分发                                                              │
│     ├── 在场者 → 完整事件描述（一手信息）                                  │
│     ├── 可推断者 → 部分信息（听到声音、看到结果）                           │
│     └── 其他人 → 不分发（除非后续有人转述）                                │
│                        │                                                 │
│                        ▼                                                 │
│  4. 各Flash独立处理                                                       │
│     ├── 事件摄入（编码为节点/边）                                          │
│     ├── 状态更新（情绪、目标）                                             │
│     └── 可能触发自主行动（NPC想去做某事）                                  │
│                                                                          │
└──────────────────────────────────────────────────────────────────────────┘

```

### 5.2 事件结构

```yaml
Event:
  id: string
  type: EventType           # scene_change, dialogue, action, combat, system
  timestamp: datetime
  game_day: int

  location: string          # 发生地点
  participants: list        # 参与者列表
  witnesses: list           # 目击者列表（不同于参与者）

  content:
    raw: string             # 原始描述
    structured: dict        # 结构化数据（如战斗结果）

  visibility:
    public: bool            # 是否公开事件
    知情者: list            # 如果不公开，谁知道

  consequences:             # 后果（可选）
    state_changes: dict
    triggered_events: list

```

### 5.3 分发逻辑

```python
def distribute_event(event, gm_flash, all_characters):
    # GM总是记录完整事件
    gm_flash.ingest_event(event, perspective="omniscient")

    for char in all_characters:
        # 判断这个角色是否应该知道
        if char.id in event.participants:
            # 参与者：完整信息 + 第一人称视角
            char.flash.ingest_event(event, perspective="participant")

        elif char.id in event.witnesses:
            # 目击者：完整信息 + 第三人称视角
            char.flash.ingest_event(event, perspective="witness")

        elif char.current_location == event.location:
            # 在场但未直接参与：可能是部分信息
            char.flash.ingest_event(event, perspective="bystander")

        elif event.visibility.public:
            # 公开事件：所有人都知道（如天气变化）
            char.flash.ingest_event(event, perspective="public_knowledge")

        # 其他情况：不分发

```

### 5.4 信息传播（二手信息）

当NPC之间对话时，信息会传播，但会有标记：

```
原始事件：玩家在森林救了Marcus

Marcus的记忆：
  event_001: {
    summary: "冒险者救了我",
    source: "self",  # 一手信息
    reliability: 1.0
  }

Marcus告诉Gorn之后，Gorn的记忆：
  rumor_001: {
    summary: "Marcus说冒险者在森林救了他",
    source: "marcus",  # 二手信息
    reliability: 0.8   # Marcus可信度
  }

如果Gorn再告诉Lily，Lily的记忆：
  rumor_002: {
    summary: "Gorn说Marcus被冒险者救了",
    source: "gorn",    # 三手信息
    reliability: 0.6   # 进一步衰减
  }

```

---

## 第六部分：Pro的运作方式

### 6.1 Pro的上下文组装

```
Pro的128K上下文组装：
┌────────────────────────────────────────────────────────────────┐
│ [系统提示] ~2K tokens                                          │
│ ├── 你是谁（名字、职业、性格）                                   │
│ ├── 你的说话风格                                               │
│ ├── 当前情绪状态                                               │
│ └── 核心行为准则                                               │
├────────────────────────────────────────────────────────────────┤
│ [场景上下文] ~3K tokens                                        │
│ ├── 当前场景描述                                               │
│ ├── 在场的其他人                                               │
│ └── 环境氛围                                                   │
├────────────────────────────────────────────────────────────────┤
│ [Flash注入的记忆] ~10K tokens（动态）                           │
│ ├── 场景进入时的基础记忆包                                      │
│ └── 对话过程中按需检索的记忆                                    │
├────────────────────────────────────────────────────────────────┤
│ [对话历史] 剩余空间                                             │
│ └── 当前场景内的所有对话                                        │
└────────────────────────────────────────────────────────────────┘

```

### 6.2 Pro请求记忆的时机

Pro不是每句话都请求Flash，而是通过特定的机制触发：

**方式A：显式工具调用**

```
Pro在生成过程中可以调用工具：
recall_memory(query="关于侄子Marcus的事")

```

**方式B：关键词触发**

```
如果玩家的话包含Pro记忆中不存在的实体/事件引用：
→ 自动触发Flash检索
→ 结果注入后重新生成

```

**方式C：场景预加载**

```
进入新场景时：
→ Flash生成"场景相关记忆包"
→ 一次性注入Pro上下文

```

### 6.3 Pro的系统提示模板

```markdown
# 你是 {character_name}

## 基本信息
- 职业: {occupation}
- 年龄: {age}
- 所在地: {current_location}

## 性格特点
{personality_description}

## 说话风格
{speech_pattern}
例句: "{example_dialogue}"

## 当前状态
- 情绪: {current_mood}
- 正在做: {current_activity}
- 目标: {active_goals}

## 你知道的重要事情
{flash_injected_memories}

## 互动规则
1. 始终保持角色扮演，不要跳出角色
2. 你只知道你的记忆中有的事情
3. 如果被问到不知道的事，就说不知道
4. 你的回答应该反映你的性格和情绪
5. 如果需要回忆更多细节，可以调用 recall_memory 工具

## 当前场景
{scene_description}

## 在场的人
{present_characters}

```

---

## 第七部分：GM的特殊地位

### 7.1 GM Flash vs 角色Flash

| 方面 | 角色Flash | GM Flash |
| --- | --- | --- |
| 视角 | 第一人称、有限信息 | 全知视角、完整信息 |
| 图谱内容 | 个人经历和认知 | 全部事件、所有剧情线 |
| 写入权限 | 只能写自己的图谱 | 可以写任何图谱（但一般通过事件分发） |
| 主要职责 | 编码记忆、检索记忆 | 记录事件、分发事件、编排剧情 |

### 7.2 GM Flash的额外职责

**剧情编排：**

```
GM Flash 监控:
├── 主线任务进度
├── 支线任务状态
├── 世界时间流逝
├── NPC日程表
└── 潜在的剧情触发点

当条件满足时:
→ 生成"导演指令"发给GM Pro
→ GM Pro根据指令描述场景/推进剧情

```

**NPC自主行为：**

```
即使玩家不在场，NPC也有自己的生活：
GM Flash 可以模拟:
├── Marcus继续打猎
├── Gorn在铁匠铺工作
├── 暗处的阴谋在推进

这些会作为"后台事件"记录，
当玩家遇到相关NPC时体现出来。

```

### 7.3 GM Pro的职责

```
GM Pro 是唯一面向玩家的"叙述者"：
├── 描述场景和环境
├── 裁决玩家行动的结果
├── 扮演不重要的路人NPC（没有独立Flash的）
├── 推进剧情
└── 协调战斗MCP

```

---

## 第八部分：与战斗MCP的整合

### 8.1 战斗触发流程

```
玩家: "我攻击那个哥布林！"
        │
        ▼
┌─────────────────────────────────────┐
│ GM Pro 判断：触发战斗               │
│ → 收集战斗信息                      │
│   ├── 敌人配置（从场景数据）         │
│   ├── 玩家状态                      │
│   └── 环境因素                      │
└─────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────┐
│ 调用战斗MCP: start_combat()         │
│ → 战斗独立运行                      │
│ → 回合制循环                        │
│ → 返回战斗结果                      │
└─────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────┐
│ 战斗结果 → 事件                     │
│ {                                   │
│   type: "combat_result",            │
│   outcome: "victory",               │
│   participants: ["player", "gob1"], │
│   damage_taken: 5,                  │
│   loot: ["rusty_key"],              │
│   xp: 50                            │
│ }                                   │
└─────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────┐
│ GM Flash 处理战斗事件               │
│ → 写入全局图谱                      │
│ → 分发给参与者                      │
│   ├── 玩家（如果有角色图谱）         │
│   └── 在场的NPC                     │
└─────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────┐
│ GM Pro 叙述战斗结果                 │
│ "经过一番激烈的战斗，你成功击败了    │
│  哥布林。在它的尸体上，你发现了      │
│  一把生锈的钥匙..."                 │
└─────────────────────────────────────┘

```

### 8.2 NPC的战斗记忆

如果NPC目睹了战斗：

```
Marcus的Flash收到事件：
"冒险者在森林击败了两只哥布林"

编码为记忆：
  event_xxx: {
    summary: "我亲眼看到冒险者独自击败了两只哥布林，真是厉害",
    emotion: "impressed",
    importance: 0.7
  }

  edge: (player) --demonstrated_strength_to--> (SELF)
        weight: 0.8

```

---

## 第九部分：施工计划

### Phase 1：图谱基础设施（1-2周）

**目标：** 能够创建、存储、查询图谱

**模块：**

1. `MemoryGraph` 类
    - 封装NetworkX
    - 节点/边的CRUD
    - 序列化/反序列化
2. `GraphStore` 类
    - Firestore读写
    - 缓存机制
    - 事务支持
3. `SpreadingActivation` 算法
    - 基础激活扩散
    - 参数可配置
    - 子图提取

**验收标准：**

- 能创建一个测试图谱
- 能执行激活扩散并返回结果
- 能持久化到Firestore

### Phase 2：世界观图谱（1周）

**目标：** 建立博得之门世界的基础知识图谱

**工作：**

1. 定义Schema（实体类型、关系类型）
2. 准备世界观文档
3. 编写LLM提取Prompt
4. 批量提取并人工review
5. 导入到Firestore

**验收标准：**

- 有一个可用的世界观图谱
- 包含主要地点、NPC、组织
- 能查询实体和关系

### Phase 3：单角色Flash（1-2周）

**目标：** 让一个NPC能够记忆和回忆

**模块：**

1. Flash服务
    - 事件摄入接口
    - 记忆检索接口
    - Gemini Flash调用封装
2. Prompt模板
    - 事件编码Prompt
    - 查询理解Prompt
    - 记忆翻译Prompt
3. 测试CLI
    - 手动发送事件
    - 手动查询记忆
    - 观察图谱变化

**验收标准：**

- 能给Gorn发送"玩家帮你修炉子"事件
- Gorn的图谱中出现相应节点
- 查询"玩家"能返回相关记忆

### Phase 4：单角色Pro + Flash联动（1周）

**目标：** 让NPC能够在对话中使用记忆

**模块：**

1. Pro服务
    - 对话处理接口
    - 上下文组装
    - 工具调用支持
2. Flash-Pro通信
    - 记忆请求协议
    - 记忆注入机制
3. 集成测试
    - 和Gorn对话
    - 问他关于玩家的事
    - 验证记忆被正确检索

**验收标准：**

- 和Gorn对话，他能记得玩家帮他修过炉子
- 问无关的事，他不会瞎编

### Phase 5：GM Flash + 事件总线（1-2周）

**目标：** 实现多角色的事件分发

**模块：**

1. GM Flash
    - 全局事件图谱
    - 事件分发逻辑
2. 事件总线
    - 事件定义
    - 分发机制
    - 多Flash订阅
3. GM Pro
    - 叙述生成
    - 场景描述

**验收标准：**

- GM记录一个事件
- 相关NPC的Flash自动收到通知
- NPC的图谱被正确更新

### Phase 6：完整游戏循环 + 战斗整合（1周）

**目标：** 跑通一个完整的游戏场景

**工作：**

1. Game Master Loop状态机
2. 战斗MCP整合
3. 场景切换逻辑
4. 端到端测试

**验收标准：**

- 玩家进入场景
- 和NPC对话
- 触发战斗
- 战斗结果被记录
- NPC记得发生了什么

---

## 第十部分：关键设计决策总结

| 决策点 | 选择 | 理由 |  |
| --- | --- | --- | --- |
| 图谱格式 | NetworkX | 成熟库，算法支持好 |  |
| 存储 | Firestore | 你已经在用，实时同步 |  |
| 激活扩散 | 程序实现 | 确定性，可测试 |  |
| Flash模型 | Gemini 3 Flash | 1M上下文，便宜 |  |
| Pro模型 | Gemini 3 Pro | 128K，质量高 |  |
| 事件分发 | 发布-订阅模式 | 解耦，可扩展 |  |
| 角色Flash独立性 | 完全独立 | 信息隔离，符合设定 |  |
| GM权限 | 只读其他图谱 | 通过事件分发影响，不直接修改 |  |

---

这就是完整的设计方案。