# 战斗系统重构计划

> 调查日期: 2026-02-13
> 分支: buyu的异世界冒险
> 调查范围: 12个Agent并行深度调查，覆盖全部战斗相关模块

---

## 一、现有模块全景

### 1.1 模块清单与完成度

| 模块 | 核心文件 | 行数 | 完成度 | 状态 |
|------|---------|------|--------|------|
| CombatEngine 核心 | `app/combat/combat_engine.py` | 1568 | 85% | 可用，需扩展 |
| 战斗数据模型 | `app/combat/models/` (5文件) | ~900 | 90% | 完整 |
| 敌人AI | `app/combat/ai_opponent.py` | 175 | 70% | 仅敌人，无队友AI |
| 敌人注册表 | `app/combat/enemy_registry.py` | 431 | 80% | 支持模板+原型+世界数据 |
| 距离系统 | `app/combat/spatial.py` | 67 | 90% | 完整 |
| 骰子系统 | `app/combat/dice.py` | 91 | 95% | 完整 |
| 法术模板 | `app/combat/spells.py` | 39 | 20% | 仅4个内置法术 |
| 状态效果 | `app/combat/effects.py` | 56 | 80% | 10种效果已实现 |
| 规则常量 | `app/combat/rules.py` | 167 | 75% | 3个敌人模板+2个物品 |
| 世界数据仓库 | `app/combat/data_repository.py` | ~200 | 70% | Firestore+本地文件 |
| 模板映射器 | `app/combat/template_mapper.py` | ~150 | 70% | 怪物→模板映射 |
| MCP服务器 | `app/combat/combat_mcp_server.py` | 794 | 90% | 17个工具完整暴露 |
| V4 Agentic工具 | `app/services/admin/v4_agentic_tools.py` | ~170行战斗 | 80% | 3个工具(start/options/action) |
| FlashCPU战斗处理 | `app/services/admin/flash_cpu_service.py` | ~100行战斗 | 80% | 自动结算+结果同步 |
| 路由层 | `app/routers/game_v2.py` | ~100行战斗 | 85% | 4个端点 |
| 主角属性 | `app/models/player_character.py` | 212 | 90% | D&D 5e完整体系 |
| 能力判定 | `app/services/ability_check_service.py` | 193 | 85% | d20+mod+熟练 |
| 物品注册表 | `app/services/item_registry.py` | ~100 | 75% | 延迟加载+搜索 |
| 队伍系统 | `app/services/party_service.py` | ~300 | 75% | 4人队伍+位置同步 |
| 队友响应 | `app/services/teammate_response_service.py` | ~400 | 75% | 2阶段LLM决策 |
| 前端战斗UI | `frontend/src/components/combat/` | 8组件 | 60% | Overlay+Arena+Actions |
| 前端骰子 | `frontend/src/components/dice/` | 1组件 | 70% | 动画+检定显示 |

### 1.2 静态数据资源

> **唯一数据源**: `data/goblin_slayer/structured_new/`（`已弃用/` 目录不再使用）

| 数据文件 | 行数 | 内容 | 战斗可用性 |
|---------|------|------|-----------|
| `characters.json` | ~300 | NPC定义：id/name/tier/occupation/personality/tags/relationships | **无战斗属性**，tags可推导角色（"治愈者"/"战士"/"施法者"） |
| `character_profiles.json` | ~300 | 同上，按id索引的另一格式 | 同上 |
| `items.json` | 720 | 物品：武器/防具/药水/工具/卷轴/素材 | 半机械化（ac_bonus为数字，damage为文本，effects为描述性） |
| `skills.json` | 1407 | 技能/法术：按职业分组（source字段区分） | 半机械化（effect含骰子表达式如"2d6"，cost如"1点魔力值"） |
| `monsters.json` | 6056 | 怪物：15+种族生态 | **最完整**（D&D六维属性+attacks含骰子+loot+challenge_rating） |
| `maps.json` | - | 地图定义 | - |
| `chapters_v2.json` | - | 章节结构 | - |
| `mainlines.json` | - | 主线剧情 | - |
| `world_graph.json` | - | 世界知识图谱 | - |
| `prefilled_graph.json` | - | 预填充图谱 | - |

#### 数据结构要点

**characters.json** — 纯叙事，无D&D属性：
```json
{
  "id": "priestess", "name": "女神官", "tier": "main",
  "occupation": "神官（冒险者）",
  "tags": ["治愈者", "神官", "主角团"]   // ← 唯一的角色暗示
}
```

**monsters.json** — 最接近D&D机械化：
```json
{
  "id": "怪物生态_-_哥布林类", "type": "humanoid",
  "challenge_rating": "白瓷",
  "stats": {"hp": 7, "ac": 15, "str": 8, "dex": 14, "con": 10, ...},
  "attacks": [{"name": "粗制弯刀", "damage": "1d6+2"}],
  "loot": ["哥布林的耳朵", "粗制的武器"]
}
```

**skills.json** — 按source归属职业，effect含半结构化骰子：
```json
{
  "id": "新-职业咒文列表_-_魔术师_(真言咒文)_火焰箭",
  "tier": 1, "type": "magic", "school": "元素",
  "source": "魔术师(真言咒文)",          // ← 可映射到角色occupation
  "effect": "造成[施法者.总能力.魔力+2d6]的火焰伤害",
  "cost": "1点魔力值", "range": "远程"
}
```

**items.json** — 嵌套数组，properties半机械化：
```json
{
  "id": "armor_leather", "type": "armor", "subtype": "light",
  "properties": {"ac_bonus": 2, "damage": null, "weight": "light", "price": "30 sp"},
  "effects": [], "rarity": "common"
}
```

---

## 二、模块间通信链路

### 2.1 战斗触发 — 两条入口路径

```
路径A: Agentic工具触发（GM决策驱动）
──────────────────────────────────
玩家输入 "我攻击哥布林"
  → PipelineOrchestrator.process() B阶段
    → FlashCPU.agentic_process_v4()
      → LLM 调用 start_combat(enemies=[...])
        → V4AgenticToolRegistry.start_combat()     [v4_agentic_tools.py:871]
          → 参数规范化（count 1-20, level 1-20）
          → FlashRequest(START_COMBAT)
            → FlashCPU.execute_request()            [flash_cpu_service.py:965]
              → 自动填充 player_state（from CharacterStore）
              → ❌ allies 不自动填充
              → _call_combat_tool("start_combat_v3") [flash_cpu_service.py:1813]
                → MCPClientPool.call_tool(COMBAT)   [mcp_client_pool.py:486]
                  → combat_mcp_server.start_combat_v3() [combat_mcp_server.py:365]
                    → CombatEngine.start_combat()    [combat_engine.py:64]
                    → 返回 {combat_id, combat_state, available_actions_v3}
              → _apply_delta(combat_id → session.game_state)

路径B: 路由层直接触发（前端按钮）
──────────────────────────────────
POST /combat/trigger
  → AdminCoordinator.trigger_combat()              [admin_coordinator.py:1312]
    → flash_cpu.call_combat_tool("start_combat_v3")
    → _apply_delta(combat_id)
    → 获取 available_actions
    → 返回 TriggerCombatResponse
```

### 2.2 战斗行动执行链

```
路径A: Agentic工具执行
──────────────────────────────────
LLM 调用 choose_combat_action(action_id="attack_1")
  → V4AgenticToolRegistry.choose_combat_action()   [v4_agentic_tools.py:978]
    → _resolve_active_combat_id() (from session.game_state.combat_id)
    → call_combat_tool("execute_action_for_actor")
      → fallback: call_combat_tool("execute_action")
    → 返回 {action_result, combat_state}
    → IF combat_state.is_ended == True:
      → call_combat_tool("resolve_combat_session_v3", dispatch=True)
      → sync_combat_result_to_character()           [flash_cpu_service.py:1631]
        → character.current_hp = hp_remaining
        → character_service.add_xp(xp)  (触发升级逻辑)
        → character.gold += gold
        → character.add_item(item_id) for each loot
      → session.game_state.combat_id = None

路径B: 路由层执行
──────────────────────────────────
POST /combat/action {action_id}
  → AdminCoordinator.execute_combat_action()        [admin_coordinator.py:1352]
    → call_combat_tool("execute_action_v3")
    → IF is_ended:
      → resolve_combat()
      → sync_combat_result_to_character()
      → _apply_delta(combat_id=None)
    → ELSE:
      → get_available_actions_v3()
    → 返回 CombatActionResponse
```

### 2.3 SSE流中的战斗事件推送

```
process_player_input_v3_stream()                    [admin_coordinator.py:405]
  → event_queue = asyncio.Queue()
  → pipeline_task = PipelineOrchestrator.process(event_queue=...)
  → WHILE not done:
      event = event_queue.get()
      yield event  (SSE推送)
  → yield {type: "agentic_trace", agentic_trace: {...}}
  → yield {type: "gm_chunk", text: "..."}  (分块推送叙述)
  → yield {type: "complete", state_delta: {...}}

战斗相关事件类型:
  - {type: "agentic_tool_call", name: "start_combat", success: true, duration_ms: 245}
  - {type: "agentic_tool_call", name: "choose_combat_action", ...}
  - {type: "agentic_tool_call", name: "ability_check", dice_result: {...}}
```

---

## 三、CombatEngine 内部精确接口

### 3.1 核心方法调用图

```
start_combat(enemies, player_state, allies?, environment?)
├── _create_player_combatant(player_state)             → Combatant(PLAYER)
├── _create_ally_combatant(ally_state, index)           → Combatant(ALLY)  [per ally]
├── _create_enemy_combatant(enemy_data, index, world_id) → Combatant(ENEMY) [per enemy]
│   └── get_enemy_template() → 等级缩放 → Combatant
├── SimpleDistanceProvider.initialize(ids, allies)
├── _roll_initiative(session) → d20 + initiative_bonus [per combatant]
├── sort turn_order by initiative_roll DESC
└── 检查第一个行动者:
    ├── 玩家/队友 → _set_waiting_player_input()
    └── 敌人 → _begin_turn() + _run_enemy_turns_until_player()

execute_action(combat_id, action_id)
├── _begin_turn(session)
│   ├── reset_turn_resources()
│   └── apply_start_of_turn_effects() (burn/poison伤害)
├── [action_id 解析分发]:
│   ├── "attack_{target}" → _execute_attack()
│   │   ├── distance检查 (ENGAGED/CLOSE)
│   │   ├── _roll_d20_with_advantage(advantage_state)
│   │   ├── hit_total = d20 + attack_bonus vs target.get_effective_ac()
│   │   ├── DiceRoller.roll(damage_dice) + damage_bonus
│   │   ├── _apply_damage_modifiers(target, damage, type)  [抗性/易伤/免疫]
│   │   └── target.take_damage()
│   ├── "offhand_{target}" → _execute_offhand_attack()      [bonus_action]
│   ├── "throw_{target}" → _execute_throw()                 [NEAR/FAR/CLOSE]
│   ├── "shove_{target}" → _execute_shove()                 [ENGAGED, STR对抗]
│   ├── "defend" → _execute_defend()                        [DEFENDING +2AC]
│   ├── "dash" → _execute_dash()                            [+speed移动点]
│   ├── "disengage" → _execute_disengage()                  [DISENGAGED效果]
│   ├── "spell_{id}_{target}" → _execute_spell()            [法术位检查+效果]
│   ├── "use_{item_id}" → _execute_use_item()               [硬编码药水]
│   ├── "flee" → _execute_flee()                            [d20 vs DC10]
│   ├── "move_*" → _execute_move()                          [距离调整+借机攻击]
│   └── "end_turn" → 直接结束
├── _record_action_logs()
├── session.check_combat_end()  → VICTORY(全灭)/DEFEAT(玩家死)/FLED
└── [后续处理]:
    ├── 敌人回合 → _end_turn() + _run_enemy_turns_until_player()
    │   └── _execute_enemy_turn()
    │       ├── OpponentAI.decide_action(enemy) → ATTACK/DEFEND/FLEE
    │       └── 执行对应行动
    └── 玩家回合 → _set_waiting_player_input()
```

### 3.2 行动生成条件一览

| 行动类型 | action_id | 消耗 | 条件 |
|---------|-----------|------|------|
| 近战攻击 | `attack_{enemy}` | action | 距离 ENGAGED/CLOSE |
| 副手攻击 | `offhand_{enemy}` | bonus | ENGAGED/CLOSE + 有offhand |
| 投掷 | `throw_{enemy}` | action | 距离 CLOSE/NEAR/FAR |
| 推撞 | `shove_{enemy}` | bonus | 距离 ENGAGED |
| 防御 | `defend` | action | 无 |
| 脱离 | `disengage` | action | 有ENGAGED的敌人 |
| 疾跑 | `dash` | action | 无 |
| 物品 | `use_healing_potion` | bonus | **硬编码** |
| 法术 | `spell_{id}_{target}` | action/bonus | 法术位+距离范围 |
| 逃跑 | `flee` | action | 无 |
| 移动 | `move_closer/away` | movement | movement_points > 0 |
| 结束回合 | `end_turn` | 无 | 始终可用 |

### 3.3 等级缩放公式

```
敌人模板等级缩放（combat_engine._create_enemy_combatant）:
  level_delta = max(0, level - 1)
  HP = template.max_hp × (1 + 0.15 × level_delta)
  attack_bonus = template.attack_bonus + (level_delta // 2)
  damage_bonus = template.damage_bonus + (level_delta // 2)
  initiative_bonus = template.initiative_bonus + (level_delta // 3)
  AC = template.ac + (level_delta // 3)

原型生成（enemy_registry.generate_template_from_archetype）:
  base_hp = 10 + tier × 8
  base_ac = 12 + (tier // 2)
  base_attack_bonus = 2 + tier
  base_damage_bonus = max(1, tier // 2)
  base_initiative_bonus = tier // 2
  → 再乘以 role_modifiers（brute/skirmisher/tank/caster/archer）
```

---

## 四、关键缺口详解

### 缺口 1: 队友无法参加战斗（P0 最高优先级）

**根因链**：
```
PartyMember 模型仅有社交属性（name/role/personality/mood）
  → 无 HP/AC/attack_bonus/damage_dice 等战斗字段
    → 无 to_combat_ally_state() 转换方法
      → FlashCPU.execute_request() 中 allies=params.get("allies") 无自动填充
        → start_combat 时 allies 为空
          → 队友在战斗中不存在
```

**对比玩家**：PlayerCharacter 有完整的 `to_combat_player_state()` 方法，FlashCPU 会自动填充 `player_state`。

**NPC数据现状**：`structured_new/characters.json` 仅有叙事数据（occupation/personality/tags），无任何 D&D 战斗属性。但 `tags` 字段（如 "治愈者"/"战士"/"施法者"/"弓箭手"）可作为角色→职业的映射依据。注意：`character_creation.json`（含种族/职业D&D模板）仅存在于 `已弃用/` 目录，`structured_new/` 中没有此文件。

### 缺口 2: 队友在战斗中无法行动（P0）

**现状**：
- `CombatantType.ALLY` 已定义，ally 会参与先攻和回合顺序
- `_run_enemy_turns_until_player()` 中当轮到玩家/队友时调用 `_set_waiting_player_input()`
- **但没有 Ally AI** — 只有 `OpponentAI` 给敌人用
- `choose_combat_action(actor_id="player")` 默认只处理玩家
- 队友回合无人接管 → 卡死或被跳过

### 缺口 3: 物品使用硬编码（P1）

**现状**：
- `_execute_use_item()` 从 `ITEM_EFFECTS` 查找，仅有 `healing_potion` 和 `greater_healing_potion`
- `get_available_actions` 硬编码生成 `use_healing_potion`
- 无法使用库存中的其他物品
- item_registry 有 720 行物品数据但战斗引擎不查询

### 缺口 4: 法术系统未桥接（P1）

**现状**：
- `SPELL_TEMPLATES` 仅 4 个内置法术（fire_bolt/magic_missile/healing_word/ray_of_frost）
- `skills.json` 有 100+ 法术数据但未映射到 `spells_known`
- `template_mapper.skill_to_spell_template()` 存在但未在战斗触发时调用
- `CombatDataRepository.list_skills()` 可加载但未被 start_combat 使用

### 缺口 5: 战斗结算不完整（P1）

**已实现**：
- HP 同步（`character.current_hp = hp_remaining`）
- XP 同步（`add_xp()` 触发升级逻辑）
- 金币同步（`character.gold += gold`）

**缺失**：
- 队友 HP 不同步（PartyMember 无 HP 字段）
- 物品掉落未实现（`_calculate_rewards()` 中 items 始终为空列表）
- 好感度不自动更新（`update_disposition_after_combat()` 需手动调用）
- 战斗事件不触发章节推进检查

### 缺口 6: 战斗中队友响应逻辑错位（P2）

**现状**：
- C阶段 `TeammateResponseService.process_round_stream()` **无条件执行**
- 战斗中队友应通过 Ally AI 行动，而非生成对话

---

## 五、重构方案

### Phase 1: 队友战斗属性体系（P0）

**目标**: 让队友能够带着完整D&D属性参加战斗

#### 1.1 扩展 PartyMember 模型

**文件**: `app/models/party.py`

新增战斗属性块：
```python
class PartyMember(BaseModel):
    # ... 现有字段保持不变 ...

    # ===== 战斗属性（新增）=====
    level: int = 1
    character_class: Optional[str] = None        # "fighter"/"priest"/"mage" 等
    race: Optional[str] = None                   # "human"/"elf" 等
    abilities: Dict[str, int] = Field(default_factory=lambda: {
        "str": 10, "dex": 10, "con": 10, "int": 10, "wis": 10, "cha": 10
    })
    max_hp: int = 20
    current_hp: int = 20
    ac: int = 13
    proficiency_bonus: int = 2
    initiative_bonus: int = 0

    # 装备与攻击
    equipment: Dict[str, Optional[str]] = Field(default_factory=dict)
    attack_bonus: int = 2
    damage_dice: str = "1d6"
    damage_bonus: int = 1
    damage_type: str = "slashing"

    # 法术
    spells_known: List[str] = Field(default_factory=list)
    spell_slots: Dict[int, int] = Field(default_factory=dict)

    # 转换方法
    def to_combat_ally_state(self) -> Dict[str, Any]: ...
```

#### 1.2 实现 `to_combat_ally_state()`

逻辑参考 `PlayerCharacter.to_combat_player_state()`：
- 从 abilities 计算修正值
- 从 equipment 查询武器属性（通过 item_registry）
- 构造战斗引擎所需的 ally_state dict

#### 1.3 FlashCPU 自动填充 allies

**文件**: `app/services/admin/flash_cpu_service.py` (START_COMBAT 分支)

```python
# 新增：自动从队伍填充 allies
if not params.get("allies"):
    party = session.party  # 从 SessionRuntime 获取
    if party:
        allies = [
            member.to_combat_ally_state()
            for member in party.get_active_members()
        ]
```

#### 1.4 NPC 战斗属性初始化

**方案**: 添加队友时，根据 tags/occupation 和 level 自动生成 D&D 属性

> **数据源现状**: `structured_new/characters.json` 无D&D属性，`character_creation.json` 仅在 `已弃用/` 中。
> 需要**内置职业原型表**替代外部数据文件。

```python
# 新增：内置职业原型表（替代已弃用的character_creation.json）
# 文件: app/combat/class_templates.py
CLASS_TEMPLATES = {
    "fighter": {   # tags含 "战士"/"前卫" → fighter
        "hit_die": "d10", "base_hp": 10,
        "primary_abilities": {"str": 16, "con": 14, "dex": 12},
        "base_ac": 16,  # 锁子甲+盾
        "attack_bonus": 5, "damage_dice": "1d8", "damage_bonus": 3,
        "damage_type": "slashing",
        "default_equipment": {"main_hand": "longsword", "armor": "chain_mail", "off_hand": "shield"},
    },
    "priest": {    # tags含 "治愈者"/"神官" → priest
        "hit_die": "d8", "base_hp": 8,
        "primary_abilities": {"wis": 16, "con": 14, "str": 12},
        "base_ac": 14,  # 链甲衫
        "attack_bonus": 3, "damage_dice": "1d6", "damage_bonus": 1,
        "damage_type": "bludgeoning",
        "default_spells": ["healing_word", "sacred_flame", "shield_of_faith"],
    },
    "mage": {      # tags含 "施法者"/"魔法师" → mage
        "hit_die": "d6", "base_hp": 6,
        "primary_abilities": {"int": 16, "dex": 14, "con": 12},
        "base_ac": 12,  # 无甲+DEX
        "attack_bonus": 2, "damage_dice": "1d4", "damage_bonus": 0,
        "damage_type": "bludgeoning",
        "default_spells": ["fire_bolt", "magic_missile", "sleep"],
    },
    "ranger": {    # tags含 "弓箭手"/"游侠" → ranger
        "hit_die": "d10", "base_hp": 10,
        "primary_abilities": {"dex": 16, "wis": 14, "con": 12},
        "base_ac": 14,  # 皮甲+DEX
        "attack_bonus": 5, "damage_dice": "1d8", "damage_bonus": 3,
        "damage_type": "piercing",
        "default_equipment": {"main_hand": "longbow", "armor": "leather"},
    },
    # ... scout/support 等
}

# tags → class 映射规则
TAG_TO_CLASS = {
    "战士": "fighter", "前卫": "fighter",
    "治愈者": "priest", "神官": "priest",
    "施法者": "mage", "魔法师": "mage",
    "弓箭手": "ranger", "游侠": "ranger",
    "斥候": "scout", "盗贼": "rogue",
}

# PartyService.add_member() 中新增
def _initialize_combat_stats(member: PartyMember, character_data: dict) -> None:
    """根据 character_data.tags 和 level 初始化战斗属性"""
    # 1. 从 tags 推导 character_class
    cls = _resolve_class_from_tags(character_data.get("tags", []))
    template = CLASS_TEMPLATES[cls]
    # 2. 应用等级缩放
    # 3. HP = hit_die_avg × level + CON_mod × level
    # 4. 设置 attack_bonus, damage_dice, AC 等
```

---

### Phase 2: 队友战斗AI（P0）

**目标**: 队友能在战斗回合中自动行动

#### 2.1 实现 AllyAI 类

**新文件**: `app/combat/ai_ally.py`

```python
class AllyAI:
    """队友战斗AI — 基于角色role的决策"""

    ROLE_STRATEGIES = {
        "warrior": WarriorStrategy,   # 优先近战攻击最弱敌人
        "healer": HealerStrategy,     # 优先治疗低HP队友，其次攻击
        "mage": MageStrategy,         # 优先远程法术，保持距离
        "rogue": RogueStrategy,       # 优先攻击受伤敌人，利用优势
        "support": SupportStrategy,   # 防御+治疗
    }

    def decide_action(self, ally: Combatant, session: CombatSession) -> ActionOption:
        """根据角色role选择最优行动"""
```

#### 2.2 修改 CombatEngine 的回合处理

**文件**: `app/combat/combat_engine.py`

`_run_enemy_turns_until_player()` → 重命名为 `_run_npc_turns_until_player()`

```python
def _run_npc_turns_until_player(self, session):
    while session.state != ENDED:
        current = session.get_current_actor()
        if current.is_enemy():
            # 敌人AI（现有逻辑）
            action = OpponentAI(session).decide_action(current)
            self._execute_action_for_npc(session, current, action)
        elif current.is_ally():
            # 队友AI（新增）
            action = AllyAI(session).decide_action(current)
            self._execute_action_for_npc(session, current, action)
        elif current.is_player():
            self._set_waiting_player_input(session)
            return
        # 推进回合...
```

---

### Phase 3: 物品系统桥接（P1）

**目标**: 战斗中能使用库存中的消耗品

#### 3.1 扩展 get_available_actions 中的物品选项

**文件**: `app/combat/combat_engine.py`

替换硬编码物品逻辑：
```python
# 旧：硬编码 use_healing_potion
# 新：从 session.environment["player_inventory"] 查询可用消耗品
for item in session.environment.get("player_inventory", []):
    item_data = get_item(item["item_id"])
    if item_data and item_data.get("type") in ("potion", "consumable"):
        actions.append(ActionOption(
            action_id=f"use_{item['item_id']}",
            action_type=ActionType.USE_ITEM,
            display_name=item_data["name"],
            description=item_data.get("description", ""),
            item_id=item["item_id"],
            cost_type="bonus",
        ))
```

#### 3.2 扩展 _execute_use_item

从 item_registry 查询物品效果，替代硬编码的 ITEM_EFFECTS：
- 治疗药水 → 恢复 HP
- 解毒剂 → 移除 POISONED
- 体力药水 → 临时增加属性
- 投掷物 → 造成伤害

#### 3.3 战斗启动时注入库存

在 `start_combat_v3` MCP 工具中，将玩家库存注入 `environment`：
```python
environment["player_inventory"] = player_character.inventory
```

---

### Phase 4: 法术系统桥接（P1）

**目标**: 世界数据中的法术能在战斗中使用

#### 4.1 自动加载法术模板

在 `combat_mcp_server.start_combat_v3()` 中（已有 `include_skill_templates` 参数）：

```python
if include_skill_templates:
    repo = CombatDataRepository(world_id)
    skills = repo.list_skills()
    spell_templates = {}
    for skill in skills:
        tmpl = skill_to_spell_template(skill)
        if tmpl:
            spell_templates[tmpl["id"]] = tmpl
    environment["skill_templates"] = spell_templates
```

#### 4.2 玩家法术列表桥接

`PlayerCharacter.to_combat_player_state()` 已包含 `spells_known` 和 `spell_slots`。
需确保 `spells_known` 中的 ID 与 `skill_templates` 中的 key 匹配。

#### 4.3 队友法术列表

`PartyMember.to_combat_ally_state()` 需根据角色职业提供 `spells_known`：
- priest/mage 角色自动获得对应等级的法术列表
- **数据来源**: `structured_new/skills.json` 的 `source` 字段按职业分组
  - `source: "魔术师(真言咒文)"` → mage 可用法术
  - `source: "神官(奇迹)"` → priest 可用法术
  - 根据 `tier` 字段过滤当前等级可用法术
- 通过 `CombatDataRepository.list_skills()` 加载 → 按 source 过滤 → `skill_to_spell_template()` 转换

---

### Phase 5: 战斗结算完善（P1）

#### 5.1 物品掉落系统

**文件**: `app/combat/combat_engine.py` `_calculate_rewards()` 方法

```python
def _calculate_rewards(self, session):
    # 现有：xp + gold 累加
    # 新增：从敌人模板的 loot 字段生成掉落
    for enemy in defeated_enemies:
        template = get_enemy_template(enemy_type)
        for loot_entry in template.get("loot", []):
            if random.random() < loot_entry.get("drop_rate", 0.5):
                items.append(loot_entry["item_id"])
```

#### 5.2 队友HP同步

战斗结束后，将 Ally Combatant 的 HP 写回 PartyMember：
```python
# sync_combat_result_to_character 中新增
for combatant in combat_state.get("combatants", []):
    if combatant["type"] == "ally":
        member = party.get_member(combatant["id"])
        if member:
            member.current_hp = combatant["hp"]
```

#### 5.3 好感度自动更新

在 `choose_combat_action()` 的自动结算逻辑中追加：
```python
if combat_state.get("is_ended"):
    # ... 现有结算逻辑 ...
    # 新增：自动更新好感度
    await self.flash_cpu.update_disposition_after_combat(
        self.world_id, self.session_id, resolve_payload
    )
```

---

### Phase 6: 战斗模式切换（P2）

#### 6.1 C阶段队友行为模式切换

**文件**: `app/services/admin/pipeline_orchestrator.py` C阶段

```python
# C3: 队友响应
if party and party.get_active_members():
    if session.game_state and session.game_state.combat_id:
        # 战斗中：跳过对话响应，队友通过AllyAI在战斗引擎中行动
        pass
    else:
        # 非战斗：执行正常的对话响应
        async for tm_event in self.teammate_response_service.process_round_stream(...):
            ...
```

---

### Phase 7: 前端战斗体验优化（P2）

#### 7.1 队友显示

在 CombatOverlay 中显示队友单位（使用现有 CombatantCard 组件）

#### 7.2 物品使用面板

在 ActionOptionList 中支持展示消耗品选项

#### 7.3 法术面板

在 ActionOptionList 中按法术等级分组展示法术选项

#### 7.4 战斗叙述增强

通过 SSE 流推送每轮战斗的 LLM 叙述（在每个 action_result 后生成）

---

## 六、实施优先级与依赖关系

```
Phase 1: 队友战斗属性 ─────────────────┐
  ├─ 1.1 扩展 PartyMember 模型          │
  ├─ 1.2 to_combat_ally_state()         │
  ├─ 1.3 FlashCPU 自动填充 allies       ├─► Phase 2: 队友AI
  └─ 1.4 NPC 属性初始化                 │     ├─ 2.1 AllyAI 类
                                        │     └─ 2.2 修改回合处理
Phase 3: 物品桥接 ──────────────────────┤
  ├─ 3.1 动态物品选项                    │
  ├─ 3.2 扩展 use_item                  │
  └─ 3.3 库存注入                       │
                                        ├─► Phase 5: 结算完善
Phase 4: 法术桥接 ──────────────────────┤     ├─ 5.1 掉落
  ├─ 4.1 自动加载法术模板               │     ├─ 5.2 队友HP同步
  ├─ 4.2 玩家法术桥接                   │     └─ 5.3 好感度
  └─ 4.3 队友法术列表                   │
                                        └─► Phase 6: 模式切换
                                              └─► Phase 7: 前端优化
```

### 建议实施顺序

| 批次 | Phase | 预计改动文件数 | 核心风险 |
|------|-------|--------------|---------|
| **第一批** | Phase 1 + 2 | 5-7 | 队友属性初始化逻辑复杂 |
| **第二批** | Phase 3 + 4 | 3-5 | 法术ID匹配可能有数据不一致 |
| **第三批** | Phase 5 | 3-4 | 多系统同步的原子性 |
| **第四批** | Phase 6 + 7 | 4-6 | 前后端联调 |

---

## 七、关键数据格式参考

### 7.1 player_state（战斗引擎输入）

```python
{
    "name": str,
    "hp": int, "max_hp": int, "ac": int,
    "level": int,
    "abilities": {"str": int, "dex": int, "con": int, "int": int, "wis": int, "cha": int},
    "proficiency_bonus": int,
    "initiative_bonus": int,
    "attack_bonus": int,
    "damage_dice": str,    # "1d8"
    "damage_bonus": int,
    "damage_type": str,    # "slashing"
    "equipment": {"main_hand": str, "armor": str, ...},
    "spells_known": [str],
    "spell_slots": {1: int, 2: int, ...},
    "spell_slots_used": {1: int, ...},
    "class": str, "race": str,
}
```

### 7.2 ally_state（目标格式，Phase 1 产出）

```python
{
    "id": str,             # character_id
    "name": str,
    "hp": int, "max_hp": int, "ac": int,
    "attack_bonus": int,
    "damage_dice": str, "damage_bonus": int, "damage_type": str,
    "initiative_bonus": int,
    "abilities": {...},
    "spells_known": [str],
    "spell_slots": {int: int},
    "speed": int,
}
```

### 7.3 enemy_data（V4工具输入）

```python
{
    "enemy_id": str,       # 模板ID
    "count": int,          # 1-20
    "level": int,          # 1-20
    "variant": str?,
    "template_version": str?,
    "tags": [str],
    "overrides": {"hp": int, "ac": int, ...},
}
```

### 7.4 ActionOption（前端消费）

```python
{
    "action_id": str,      # "attack_goblin_1"
    "action_type": str,    # ActionType enum
    "display_name": str,
    "description": str,
    "target_id": str?,
    "cost_type": str?,     # "action"/"bonus"/"movement"
    "success_rate": float?,
    "range_band": str?,
    "damage_type": str?,
}
```

### 7.5 CombatResult（结算输出）

```python
{
    "combat_id": str,
    "result": str,         # "victory"/"defeat"/"fled"
    "summary": str,
    "rewards": {"xp": int, "gold": int, "items": [str]},
    "penalty": {"gold_lost": int, "respawn_location": str}?,
    "player_hp_remaining": int, "player_max_hp": int,
    "total_rounds": int,
    "total_damage_dealt": int, "total_damage_taken": int,
    "full_log": [str],
}
```

---

## 八、现有代码位置速查

| 功能 | 文件 | 关键位置 |
|------|------|---------|
| CombatEngine 核心 | `app/combat/combat_engine.py` | 全文 (1568行) |
| 战斗单位模型 | `app/combat/models/combatant.py` | Combatant 类 |
| 战斗会话 | `app/combat/models/combat_session.py` | CombatSession 类 |
| 行动类型 | `app/combat/models/action.py` | ActionType/ActionOption/ActionResult |
| 战斗结果 | `app/combat/models/combat_result.py` | CombatResult/CombatRewards |
| V3兼容层 | `app/combat/models/v3.py` | EnemySpec/CombatActionOptionV3 |
| 敌人AI | `app/combat/ai_opponent.py` | OpponentAI, AI_PERSONALITIES |
| 敌人模板 | `app/combat/enemy_registry.py` | get_template/generate_from_archetype |
| 法术模板 | `app/combat/spells.py` | SPELL_TEMPLATES (4个) |
| 距离系统 | `app/combat/spatial.py` | SimpleDistanceProvider |
| 状态效果 | `app/combat/effects.py` | apply_start_of_turn_effects |
| 规则常量 | `app/combat/rules.py` | ENEMY_TEMPLATES/ITEM_EFFECTS/AI_PERSONALITIES |
| 世界数据 | `app/combat/data_repository.py` | CombatDataRepository |
| 模板映射 | `app/combat/template_mapper.py` | monster_to_enemy_template/skill_to_spell_template |
| MCP服务器 | `app/combat/combat_mcp_server.py` | 17个工具 (794行) |
| V4战斗工具 | `app/services/admin/v4_agentic_tools.py` | start_combat:871 / get_combat_options:936 / choose_combat_action:978 |
| FlashCPU战斗 | `app/services/admin/flash_cpu_service.py` | START_COMBAT:965 / sync_result:1631 / _call_combat_tool:1813 |
| 协调器 | `app/services/admin/admin_coordinator.py` | trigger_combat:1312 / execute_combat_action:1352 |
| 路由层 | `app/routers/game_v2.py` | /trigger:727 / /action:761 / /start:793 / /resolve:809 |
| 请求/响应模型 | `app/models/game.py` | TriggerCombat*:166 / CombatAction*:182 / CombatStart*:74 / CombatResolve*:90 |
| 玩家角色 | `app/models/player_character.py` | to_combat_player_state:158 |
| 能力判定 | `app/services/ability_check_service.py` | perform_check:67 |
| 物品注册 | `app/services/item_registry.py` | get_item/search_items |
| 角色服务 | `app/services/character_service.py` | equip_item:261 / _recalculate_ac:316 / add_xp:165 |
| 队伍模型 | `app/models/party.py` | Party:69 / PartyMember:42 |
| 队伍服务 | `app/services/party_service.py` | add_member / sync_locations |
| 队友响应 | `app/services/teammate_response_service.py` | process_round_stream |
| Prompt | `app/prompts/flash_agentic_system.md` | 战斗工具描述+实体参考 |
| 前端类型 | `frontend/src/types/combat.ts` | CombatState/Combatant/DiceRoll |
| 前端Store | `frontend/src/stores/combatStore.ts` | useCombatStore |
| 前端Hook | `frontend/src/api/hooks/useCombat.ts` | useCombatAction/useStartCombat |
| 前端UI | `frontend/src/components/combat/CombatOverlay.tsx` | 全屏战斗覆盖层 |
| 骰子动画 | `frontend/src/components/dice/DiceRollDisplay.tsx` | 骰子滚动动画+检定显示 |
