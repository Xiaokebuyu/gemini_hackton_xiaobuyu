# 中心化架构重构计划

## 目标

将现有分散式架构重构为中心化管控架构，用 **System Admin Layer (Pro + Flash)** 完全替换 `GameMasterService`。

## 关键决策总结

| 决策项 | 选择 |
|--------|------|
| API兼容策略 | 破坏性升级（直接替换） |
| 输出格式 | Flash全JSON + Pro混合（叙述+元数据） |
| MCP部署 | 独立MCP Server（模块化优先） |
| 状态管理 | Flash统一写入（通过StateDelta事件） |
| 规则引擎 | Flash负责（意图解析、模式切换等确定性规则） |

## 架构对比

### 旧架构（分散式）
```
玩家 → GameMasterService (3016行) → 分散调用各子系统
         ↓
    M3/M4/M7/M8/M9/M10/M11 互相依赖
```

### 新架构（中心化）
```
                     ┌─────────────────────────────────────┐
                     │      System Admin Layer             │
                     │  ┌──────────┐    ┌─────────────┐   │
玩家 ─────────────→  │  │Pro (DM)  │←──→│Flash (CPU)  │   │
                     │  │叙述/交流 │    │规则/执行    │   │
                     │  └──────────┘    └──────┬──────┘   │
                     │                         │          │
                     │  ┌─ 会话管理 ──────────┤          │
                     │  └─ GM事件分发 ─────────┘          │
                     └─────────────────────────┼──────────┘
                                               │
                     ┌─────────────────────────┼──────────┐
                     │      MCP Tool Layer (独立Server)   │
                     │  ┌────────┐ ┌────────┐ ┌────────┐  │
                     │  │NPC实例 │ │ 路人  │ │ 章节  │  │
                     │  ├────────┤ ├────────┤ ├────────┤  │
                     │  │ 导航  │ │ 时间  │ │ 战斗  │  │
                     │  ├────────┤ ├────────┤ ├────────┤  │
                     │  │知识图谱│ │ ...   │ │       │  │
                     │  └────────┘ └────────┘ └────────┘  │
                     └────────────────────────────────────┘
```

## 核心组件设计

### 1. Pro (DM角色) - gemini-3-pro-preview (低思考)
- 与玩家直接交互，解说世界和事件（类似博德之门3）
- 对玩家行为进行评价和判定
- 请求 Flash 执行系统操作
- **输出格式**：混合（叙述文本 + 结构化元数据）
- **只读状态**：不直接修改游戏状态

### 2. Flash (CPU角色) - gemini-3-flash-preview
- **规则引擎**：处理确定性规则（意图分类、think/say模式、战斗/对话切换）
- **系统执行**：通过MCP工具协议调用子系统
- **状态管理**：唯一状态写入口，通过StateDelta事件
- **事件分发**：集成GMFlashService的视角转换和分发功能
- **输出格式**：全JSON结构化
- **会话管理**：集成GameLoopService的会话生命周期管理

### 3. NPC三层AI响应（重新设计）

| 角色层级 | 模型 | 思考级别 | 典型用途 |
|----------|------|----------|----------|
| 路人(PASSERBY) | gemini-3-flash-preview | 无思考 | 背景NPC、简单互动 |
| 次要角色(SECONDARY) | gemini-3-flash-preview | 中等思考 | 任务NPC、商人等 |
| 主要角色(MAIN) | gemini-3-pro-preview | 低思考 | 队友、重要剧情NPC |

### 4. MCP 工具层（独立Server）

所有子系统封装为独立MCP Server中的工具：

| 工具组 | 包含工具 | 来源 |
|--------|----------|------|
| NPC工具 | get_instance, npc_respond, persist_instance | instance_manager |
| 路人工具 | spawn_passerby, passerby_respond, despawn | passerby_service |
| 章节工具 | get_progress, trigger_event, advance_chapter | narrative_service |
| 导航工具 | get_location, navigate, enter/leave_sublocation | area_navigator |
| 时间工具 | get_time, advance_time, get_period | time_manager |
| 战斗工具 | start_combat, execute_action, get_result | combat_engine (已有) |
| 图谱工具 | query_graph, upsert_node, recall_memory | graph_store + flash_service |

## 文件变更清单

### 新建文件
```
app/services/admin/
├── __init__.py
├── pro_dm_service.py         # Pro DM 服务（叙述/交流）
├── flash_cpu_service.py      # Flash CPU 服务（规则/执行/状态管理）
├── state_manager.py          # 状态管理器（StateDelta事件）
└── admin_coordinator.py      # 管理员层协调器

app/models/
├── admin_protocol.py         # Pro-Flash 通信协议
└── state_delta.py            # 状态变更事件模型

app/mcp/
├── game_tools_server.py      # 独立MCP Server入口
└── tools/
    ├── __init__.py
    ├── npc_tools.py          # NPC实例池工具
    ├── passerby_tools.py     # 路人工具
    ├── narrative_tools.py    # 章节工具
    ├── navigation_tools.py   # 导航工具
    ├── time_tools.py         # 时间工具
    └── graph_tools.py        # 知识图谱工具

app/prompts/
├── pro_dm_system.md          # Pro 系统提示词
└── flash_cpu_system.md       # Flash 系统提示词
```

### 修改文件
- `app/routers/game.py` - 路由指向新协调器
- `app/routers/game_master.py` - 路由指向新协调器
- `app/tools/game_master_cli.py` - CLI指向新协调器
- `app/config.py` - 添加管理员层配置
- `app/combat/combat_mcp_server.py` - 集成会话管理到战斗MCP

### 废弃/删除文件
- `app/services/game_master_service.py` - 完全替换
- `app/services/game_loop_service.py` - 拆散集成（会话→Admin，战斗→CombatMCP）
- `app/services/gm_flash_service.py` - 已迁移为 `app/services/admin/event_service.py`
- `app/services/gm_llm_service.py` - 已迁移为 `app/services/admin/event_llm_service.py`
- `app/services/tiered_ai_service.py` - 重构为简化的三层模型选择器

## 关键数据模型

### Pro-Flash 通信协议
```python
# app/models/admin_protocol.py

class FlashOperation(str, Enum):
    # 实例管理
    SPAWN_PASSERBY = "spawn_passerby"
    NPC_DIALOGUE = "npc_dialogue"
    # 事件系统
    BROADCAST_EVENT = "broadcast_event"
    GRAPHIZE_EVENT = "graphize_event"
    RECALL_MEMORY = "recall_memory"
    # 导航/时间
    NAVIGATE = "navigate"
    UPDATE_TIME = "update_time"
    ENTER_SUBLOCATION = "enter_sublocation"
    # 战斗
    START_COMBAT = "start_combat"
    # 章节
    TRIGGER_NARRATIVE_EVENT = "trigger_narrative_event"

class FlashRequest(BaseModel):
    """Pro 向 Flash 发送的请求"""
    operation: FlashOperation
    parameters: Dict[str, Any]
    priority: Literal["low", "normal", "high"] = "normal"
    context_hint: Optional[str] = None

class FlashResponse(BaseModel):
    """Flash 返回给 Pro 的响应（全JSON）"""
    success: bool
    operation: FlashOperation
    result: Dict[str, Any]
    state_delta: Optional["StateDelta"] = None
    npc_reactions: Optional[List["NPCReaction"]] = None
    error: Optional[str] = None

class ProResponse(BaseModel):
    """Pro 返回给玩家的响应（混合格式）"""
    narration: str                    # 叙述文本
    speaker: str = "GM"               # 说话者
    flash_requests: List[str] = []    # 执行的Flash操作
    metadata: Dict[str, Any] = {}     # 结构化元数据
```

### 状态变更模型
```python
# app/models/state_delta.py

class StateDelta(BaseModel):
    """状态变更事件（Flash唯一写入口）"""
    delta_id: str
    timestamp: datetime
    operation: str
    changes: Dict[str, Any]       # 具体变更内容
    previous_values: Dict[str, Any] = {}  # 变更前值（用于回滚）

class GameState(BaseModel):
    """游戏状态（Flash管理）"""
    session_id: str
    world_id: str
    player_location: str
    sub_location: Optional[str]
    game_time: "GameTime"
    chat_mode: Literal["think", "say"]
    active_dialogue_npc: Optional[str]
    combat_id: Optional[str]
    narrative_progress: Dict[str, Any]
```

### NPC三层AI配置
```python
# app/config.py 新增

class NPCTierConfig(BaseModel):
    """NPC层级AI配置"""
    passerby_model: str = "gemini-3-flash-preview"
    passerby_thinking: Optional[str] = None  # 无思考

    secondary_model: str = "gemini-3-flash-preview"
    secondary_thinking: str = "medium"        # 中等思考

    main_model: str = "gemini-3-pro-preview"
    main_thinking: str = "low"                # 低思考
```

## 实施步骤

### Phase 1: 基础架构
**目标**：建立通信协议和状态管理基础

1. 创建 `app/models/admin_protocol.py` - Pro-Flash通信协议
2. 创建 `app/models/state_delta.py` - 状态变更模型
3. 创建 `app/services/admin/state_manager.py` - Flash状态管理器
4. 创建 `app/prompts/pro_dm_system.md` 和 `flash_cpu_system.md`
5. 更新 `app/config.py` - 添加NPC三层AI配置

**验收**：协议模型可导入，状态管理器可实例化

### Phase 2: 独立MCP Server
**目标**：将子系统封装为独立MCP Server

1. 创建 `app/mcp/game_tools_server.py` - MCP Server入口
2. 实现 `app/mcp/tools/npc_tools.py` - NPC工具（含新三层AI）
3. 实现 `app/mcp/tools/passerby_tools.py` - 路人工具
4. 实现 `app/mcp/tools/narrative_tools.py` - 章节工具
5. 实现 `app/mcp/tools/navigation_tools.py` - 导航工具
6. 实现 `app/mcp/tools/time_tools.py` - 时间工具
7. 实现 `app/mcp/tools/graph_tools.py` - 图谱工具
8. 修改 `app/combat/combat_mcp_server.py` - 集成会话管理

**验收**：`python -m app.mcp.game_tools_server` 可启动，工具可独立调用

### Phase 3: Admin Layer 核心
**目标**：实现Pro和Flash服务

1. 创建 `app/services/admin/flash_cpu_service.py`
   - 规则引擎（意图分类、模式切换）
   - MCP客户端（调用独立Server）
   - 状态写入（通过StateDelta）
   - 事件分发（集成GMFlashService逻辑）
2. 创建 `app/services/admin/pro_dm_service.py`
   - 叙述生成
   - Flash请求发送
   - 混合输出格式
3. 创建 `app/services/admin/admin_coordinator.py`
   - 请求入口
   - Pro-Flash协调

**验收**：Admin层可处理简单玩家输入，返回叙述响应

### Phase 4: 路由迁移
**目标**：更新所有调用方指向新架构

1. 修改 `app/routers/game.py` - 使用AdminCoordinator
2. 修改 `app/routers/game_master.py` - 使用AdminCoordinator
3. 修改 `app/tools/game_master_cli.py` - 使用AdminCoordinator

**验收**：所有API端点和CLI正常工作

### Phase 5: 清理
**目标**：删除旧代码

1. 删除 `app/services/game_master_service.py`
2. 删除 `app/services/game_loop_service.py`
3. 删除旧 `app/services/gm_flash_service.py`（已迁移为 `app/services/admin/event_service.py`）
4. 重构 `app/services/tiered_ai_service.py` → 简化的模型选择器
5. 代码审查和清理

**验收**：无旧代码引用，所有测试通过

## 参考实现

### MCP独立Server模式 (参考 combat_mcp_server.py)
```python
from mcp.server.fastmcp import FastMCP

game_mcp = FastMCP(
    name="Game Tools MCP",
    instructions="RPG游戏系统工具集...",
)

@game_mcp.tool()
async def spawn_passerby(world_id: str, map_id: str, ...) -> str:
    result = await passerby_service.get_or_spawn_passerby(...)
    return json.dumps(result, ensure_ascii=False)

if __name__ == "__main__":
    game_mcp.run(transport="stdio")  # 或 streamable-http
```

### Flash调用MCP工具
```python
# flash_cpu_service.py
async def execute_mcp_tool(self, tool_name: str, params: dict) -> dict:
    async with self.mcp_client.connect("stdio://game_tools_server") as client:
        result = await client.call_tool(tool_name, params)
        return json.loads(result)
```

### 状态写入模式
```python
# flash_cpu_service.py
async def write_state(self, changes: dict) -> StateDelta:
    delta = StateDelta(
        delta_id=generate_id(),
        timestamp=datetime.now(),
        operation=self.current_operation,
        changes=changes,
        previous_values=self._get_previous_values(changes.keys()),
    )
    await self.state_manager.apply_delta(delta)
    await self.persist_to_firestore(delta)
    return delta
```

## 验证方式

### 单元测试
1. Pro-Flash协议序列化/反序列化
2. StateDelta应用和回滚
3. 各MCP工具独立调用

### 集成测试
1. 启动独立MCP Server
2. Admin层通过MCP调用工具
3. 完整玩家输入流程：
   - 输入 → Flash意图分类 → MCP工具调用 → 状态更新 → Pro叙述 → 返回
4. NPC响应使用正确的三层AI模型

### 端到端测试
1. API端点 `/api/game/{world_id}/sessions/{session_id}/input` 正常响应
2. CLI `python -m app.tools.game_master_cli` 正常交互
3. 战斗流程完整运行

## 关键风险与缓解

| 风险 | 缓解措施 |
|------|----------|
| MCP Server延迟增加 | 监控延迟，必要时改为进程内调用 |
| 状态一致性问题 | StateDelta事件日志，支持回滚 |
| LLM输出不稳定（规则判断） | Flash使用严格JSON schema，增加重试 |
| 迁移过程服务中断 | 分Phase实施，每Phase独立验收 |
