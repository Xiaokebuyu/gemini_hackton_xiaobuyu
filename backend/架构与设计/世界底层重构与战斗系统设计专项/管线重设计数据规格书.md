# 管线重设计数据规格书

> 创建时间：2026-02-18
> 用途：作为章节编排提取管线（Phase 3）重新设计的技术规格依据
> 前置调研：引擎数据模型 + 工具层 + 上下文组装 + TavernCardParser 全面侦察

---

## 一、引擎消费数据模型规格

### 1.1 StoryEvent 完整字段表

引擎通过 `graph_builder.py` 的 `_build_events()` 消费 StoryEvent，以下字段的有无直接决定引擎行为。

| 字段 | 类型 | 默认值 | **引擎处理规则** |
|------|------|--------|----------------|
| `id` | str | 必需 | 用作 WorldGraph 节点 ID，格式必须是 `{chapter_id}_event_N` |
| `name` | str | 必需 | 节点 name，出现在 LLM 上下文的事件列表 |
| `description` | str | `""` | 写入 evt_props.description，LLM 可读 |
| `importance` | str | `"side"` | 写入 evt_props.importance；is_required=true 时自动升为 main |
| `is_required` | bool | `False` | 写入 evt_props.is_required |
| `is_repeatable` | bool | `False` | 控制 COOLDOWN 路径；与 cooldown_rounds 联动 |
| `cooldown_rounds` | int | `0` | is_repeatable=True 且 >0 时，生成冷却重置 Behavior |
| `activation_type` | str | `"event_driven"` | **决定解锁 Behavior 的触发器类型**（见 1.3） |
| `trigger_conditions` | ConditionGroup | 空（永真） | 用于 unlock behavior 的条件（event_driven 路径） |
| `completion_conditions` | ConditionGroup\|None | **None** | **None → 不生成 complete behavior → 只能 LLM 手动完成** |
| `on_complete` | Dict\|None | `None` | None → 不生成副作用；含字段见 1.5 |
| `stages` | List[EventStage] | `[]` | 空 → 走 completion_conditions 路径；非空 → 走 stage 路径 |
| `outcomes` | Dict[str, EventOutcome] | `{}` | 空 → 无自动结局判定；conditions 非 null 的结局生成判定 Behavior |
| `quest_giver` | str\|None | `None` | activation_type=npc_given 时的 NPC ID，写入 evt_props |
| `time_limit` | int\|None | `None` | 非 None → 生成超时 Behavior（priority=3，ACTIVE 超时→FAILED） |
| `visibility` | str | `"visible"` | 写入 evt_props，LLM 上下文不做过滤（引擎层面暂未使用） |
| `discovery_check` | Dict\|None | `None` | discovery 激活方式时用于生成 NARRATIVE_HINT 文本 |
| `recommended_level` | int\|None | `None` | 写入 evt_props，当前版本仅展示，不做机械校验 |
| `narrative_directive` | str | `""` | **LLM agentic 阶段最重要的指引，直接决定叙事质量** |

**关键：字段缺失导致 Behavior 不生成**

| 字段缺失情况 | 后果 |
|------------|------|
| `completion_conditions=None` 且 `stages=[]` | 不生成 complete behavior → 事件永远停在 ACTIVE，只能 LLM 手动调 complete_event |
| `stages[i].completion_conditions=None` | 该阶段跳过自动推进，必须 LLM 手动调 advance_stage |
| `outcomes` 空 | 无结局自动判定，LLM 需显式传 outcome_key |
| `time_limit=None` | 无超时保障，事件可无限期停在 ACTIVE |
| `is_repeatable=False` | 事件完成后不进 COOLDOWN，不可重复 |

---

### 1.2 EventStage / EventObjective 结构

```
EventStage:
  id                    str        阶段 ID（"stage_1", "stage_2"...）
  name                  str        阶段显示名称
  description           str        阶段描述
  narrative_directive   str        该阶段给 LLM 的叙事指引（ACTIVE 时可见）
  objectives            List[EventObjective]  该阶段的可追踪目标
  completion_conditions ConditionGroup|None  阶段完成条件（None→手动推进）

EventObjective:
  id                str   目标 ID（"obj_1", "obj_ask_guild"）
  text              str   目标文本（玩家可见）
  required          bool  是否必须完成（advance_stage 校验）
  completion_hint   str   给 LLM 的完成判断提示（如"当玩家与公会柜台交谈后标记完成"）
```

**阶段激活流程**：
- 事件 activate_event → current_stage 设为 stages[0].id
- stage.completion_conditions 满足 → tick 自动推进 current_stage
- 最后 stage 完成 → 事件 COMPLETED + 触发 on_complete 副作用

---

### 1.3 activation_type 与 Behavior 映射

| activation_type | 生成的解锁 Behavior | trigger | 触发时机 |
|----------------|-------------------|---------|---------|
| `npc_given` | **不生成** | 无 | 纯手动：LLM 调 activate_event |
| `auto_enter` | `bh_unlock_{id}` | ON_ENTER | 玩家进入区域 |
| `discovery` | `bh_unlock_{id}` | ON_ENTER | 进入区域 + 额外 NARRATIVE_HINT（感知检定提示） |
| `event_driven` | `bh_unlock_{id}` | ON_TICK | trigger_conditions 满足时 |
| *(其他/默认)* | `bh_unlock_{id}` | ON_TICK | trigger_conditions 满足时 |

**说明**：`auto_enter` 和 `discovery` 解锁时 trigger_conditions 被忽略（直接用 unlock_guard）。
`npc_given` 的 `trigger_conditions` 应为与 NPC 对话的条件（用作解锁提示），但不自动执行。

---

### 1.4 EventOutcome 结构

```
EventOutcome:
  description         str              结局描述
  conditions          ConditionGroup|None  自动判定条件（None→LLM手动选择/fallback）
  rewards             {xp, gold, items}    结局奖励
  reputation_changes  {faction: delta}     声望变化（写入 world_root.faction_reputations）
  unlock_events       List[str]            解锁的事件 ID
  world_flags         {key: value}         世界标记（写入 world_root.world_flags）
  narrative_hint      str              结局叙述提示
```

**结局判定规则**：
- 事件 COMPLETED 后，若有 `conditions` 非 None 的 outcome → 自动判定 Behavior 触发（priority=4）
- 没有条件满足的 outcome → LLM 应调用 `complete_event(event_id, outcome_key)`
- **必须至少有一个 `conditions=null` 的 fallback outcome**，否则事件 COMPLETED 后无结局

---

### 1.5 on_complete 完整副作用字段

```json
{
  "unlock_events": ["event_id_1", "event_id_2"],
  "add_xp": 200,
  "add_items": [{"name": "物品名", "quantity": 1}],
  "add_gold": 50,
  "reputation_changes": {"adventurer_guild": 10, "dark_guild": -5},
  "world_flags": {"goblin_nest_cleared": true},
  "narrative_hint": "事件完成后的过渡叙述提示"
}
```

**注意**：`unlock_events` 字段目前靠管线人工填写，或 P3 后处理自动推导（依赖其他事件的 trigger_conditions 中含 event_triggered 时反向推导）。

---

## 二、LLM 在 agentic 阶段能看到的事件信息

### 2.1 事件上下文结构（area_context.events）

每个可见事件的上下文字段：

```json
[
  {
    "id": "ch_1_2_event_3",
    "name": "寻找哥布林巢穴",
    "description": "公会委托玩家去找哥布林的藏身处...",
    "status": "active",
    "importance": "main",

    "completion_hint": "到达 goblin_cave 区域 且 与 npc_scout 交谈",

    "current_stage": {
      "id": "stage_2",
      "name": "追踪哥布林",
      "narrative_directive": "哥布林留下的痕迹指向森林深处...",
      "objectives": [
        {"id": "obj_track", "text": "跟踪痕迹", "required": true, "completed": false},
        {"id": "obj_scout", "text": "找到侦察点", "required": false, "completed": true}
      ]
    },
    "stage_progress": {"stage_1": true, "stage_2": false},
    "available_outcomes": [
      {"key": "find_entrance", "description": "发现巢穴入口"},
      {"key": "ambushed", "description": "被哥布林伏击"}
    ]
  }
]
```

**过滤规则**：只有 `AVAILABLE` 和 `ACTIVE` 状态的事件出现，LOCKED/COMPLETED/FAILED/COOLDOWN 均隐藏。

### 2.2 世界状态（dynamic_state）

```json
{
  "world_flags": {"goblin_nest_found": true, "temple_sealed": false},
  "faction_reputations": {"adventurer_guild": 50, "dark_cult": -30}
}
```

### 2.3 pending_flash 条件（按需注入）

当 pre-tick 发现 FLASH_EVALUATE 条件时：

```json
{
  "pending_flash_evaluations": [
    {"prompt": "玩家是否表现出害怕哥布林的迹象？"},
    {"prompt": "玩家是否已经充分理解了任务的危险性？"}
  ]
}
```

LLM 必须对每条调用 `report_flash_evaluation(prompt, result)`。

---

## 三、TavernCardParser 原始数据结构

### 3.1 WorldbookEntry 字段

```
uid            int    唯一 ID（raw entry 的 uid）
key            List[str]  触发关键词
comment        str    分类前缀（格式："卷/章名 - 子名称"）
content        str    ★ 原始全文内容（最重要！）
entry_type     str    推断类型（"story", "character", "location" 等）
entry_name     str    从 comment 提取的名称
order          int    排序权重
disable        bool   是否禁用
```

### 3.2 章节如何从 lorebook 构建

```
TavernCardParser 解析所有 entries
         ↓
_generate_mainlines() Phase 1（纯规则）
  ├─ 过滤 comment 包含"卷"或"章"的 story entries
  ├─ 按 entry.order 排序
  └─ 正则提取卷号/章号 → 生成 ch_id = "ch_{vol}_{ch}"
      chapter["description"] = entry.content[:500]  ← ★ 截断到 500 字！
         ↓
Phase 3（当前）
  chapter_orchestration.md 接收 chapter_description[:3000]  ← ★ 再次截断到 3000 字
```

**两层截断，实际喂给 Phase 3 的内容已是原文的 10-30%。**

### 3.3 原始 content 的典型结构（lorebook 章节条目）

```
第三卷第二章：冒险者

=== 主要目标 ===
玩家需要完成以下目标才能进入下一章：
[1] 招募到至少一名冒险者同伴
[2] 通过公会的实力认证

=== 章节事件列表 ===
2.1 初到冒险者公会
玩家第一次踏入公会大厅，看到各种委托板...

2.2 接受委托
公会接待员 Guild Girl 向玩家介绍公会制度...

2.3 首次实战
玩家参加了人生中第一次有报酬的委托...

=== 玩家选择 ===
A. 独立完成委托（难度高，获得更多经验）
B. 接受公会老手的指点（难度低，获得社交收益）
C. 拒绝委托（可重新选择其他委托）

=== NPC 反应 ===
Guild Girl: 根据玩家的选择和表现给出不同的反应...

=== 系统引导 ===
当玩家完成2.3时，系统自动触发2.4...
```

这个结构完全可以映射到 StoryEvent 字段，但当前被截断丢失。

### 3.4 章节 → lorebook entry 反向映射（当前缺失，需新增）

**问题**：`chapter["id"] = "ch_1_2"` 但没有存 `source_entry_uid`，无法快速查找原文。

**解决方案**：在 Phase 1 构建章节时同时保存：

```python
chapter["_source_entry_uid"] = entry.uid       # 原始 entry UID
chapter["_source_entry_order"] = entry.order   # 排序权重（辅助）
chapter["_full_content"] = entry.content       # 原始全文（不截断）
```

这些字段在 Phase 3 时可以直接替换 `[:3000]` 截断，喂给 LLM。

---

## 四、当前差距分析

### 4.1 字段覆盖率

| 字段 | 当前覆盖率 | 阻断效果 |
|------|----------|---------|
| `trigger_conditions` | 322/323 (99.7%) | 良好 |
| `completion_conditions` | **0/323 (0%)** | **所有事件只能 LLM 手动 complete** |
| `on_complete` | **0/323 (0%)** | **无任何自动奖励** |
| `activation_type` | **0/323 (0%)** | **全部走 ON_TICK 轮询** |
| `importance` | **0/323 (0%)** | **全部默认 side** |
| `narrative_directive` | 323/323 (100%) | 良好 |
| `stages` | **0/323 (0%)** | **无多阶段任务** |
| `outcomes` | **0/323 (0%)** | **无分支结局** |
| `quest_giver` | **0/323 (0%)** | 影响 npc_given 激活方式 |
| `time_limit` | **0/323 (0%)** | 无时限压力机制 |
| `discovery_check` | **0/323 (0%)** | discovery 类事件无检定提示 |

### 4.2 lorebook 内容利用率

| 信息维度 | lorebook 中是否存在 | 当前提取率 |
|---------|-------------------|----------|
| 事件触发条件 | ✅ 有结构化描述 | 99.7% |
| 事件完成条件 | ✅ "完成标志"有明确描述 | **0%** |
| 奖励/后果 | ✅ XP、物品、声望描述 | **0%** |
| 事件激活方式 | ✅ "NPC委托"/"进入区域" | **0%** |
| 玩家选择分支 | ✅ "选择A/B/C"结构 | **0%** |
| 阶段进度描述 | ✅ "2.1→2.2→2.3"编号 | **0%** |
| NPC 反应逻辑 | ✅ 详细描述 | 部分（narrative_directive） |
| 游戏规则约束 | ✅ 重要规则/时限 | **0%** |

**利用率约 10%**，有巨大提升空间。

---

## 五、新管线设计规格

### 5.1 输入规格（Phase 3 改造）

**当前**：
```python
chapter_description = ch.get("description", "")[:3000]  # 最多 3000 字
```

**新方案**：
```python
# 优先使用原始 lorebook 全文内容（_full_content 字段）
full_content = ch.get("_full_content", "") or ch.get("description", "")
# 不截断，Gemini 支持长上下文（100K+）
chapter_description = full_content
```

同时新增上下文字段：
- `{known_items}` — 已知物品列表（从 items.json）
- `{xp_reference}` — XP 参考值表（硬编码在 prompt 中）
- `{condition_types}` — 条件类型参考（硬编码在 prompt 中）

### 5.2 输出规格（新 StoryEvent JSON）

Phase 3 新 prompt 要求输出的最小完整 StoryEvent 格式：

```json
{
  "id": "{chapter_id}_event_1",
  "name": "事件名称",
  "description": "1-2句简述",
  "importance": "main | side | personal | flavor",
  "is_required": true | false,
  "activation_type": "event_driven | npc_given | auto_enter | discovery",
  "quest_giver": null | "npc_id",
  "trigger_conditions": {
    "operator": "and",
    "conditions": [...]
  },
  "completion_conditions": null | {
    "operator": "and",
    "conditions": [...]
  },
  "on_complete": {
    "add_xp": 100,
    "narrative_hint": "..."
  },
  "time_limit": null | int,
  "narrative_directive": "详细的GM叙述指引",
  "stages": [],
  "outcomes": {}
}
```

**stages 仅在以下情况填写**：
- 原文有清晰的多步骤结构（编号 2.1/2.2/2.3 或明确的阶段划分）
- 至少 2 个独立阶段，且各阶段有不同的目标和结束条件

**outcomes 仅在以下情况填写**：
- 原文有明确的选择分支（"选择A/B/C"、"杀死/放走"等）
- 不同选择导致不同结局，且有实质性的奖励/惩罚差异
- 必须包含至少一个 `conditions: null` 的 fallback

### 5.3 completion_conditions 提取策略（保守策略）

| 完成标志类型 | 提取方式 | 示例 |
|------------|---------|------|
| 到达特定地点 | `location` 条件 | "到达哥布林巢穴" → `{"type": "location", "params": {"area_id": "goblin_cave"}}` |
| 与特定 NPC 交谈 | `npc_interacted` 条件 | "与村长对话" → `{"type": "npc_interacted", "params": {"npc_id": "npc_mayor", "min_interactions": 1}}` |
| 某事件已完成 | `event_triggered` 条件 | "完成调查" → `{"type": "event_triggered", "params": {"event_id": "ch_1_2_event_2"}}` |
| 有特定队友 | `party_contains` 条件 | "带着弓手" → `{"type": "party_contains", "params": {"character_id": "npc_archer"}}` |
| 主观判断（说服/赢得信任） | `flash_evaluate` 条件 | "说服了村长" → `{"type": "flash_evaluate", "params": {"prompt": "玩家是否已成功说服了村长？"}}` |
| 不明确 | `null` | 留给 LLM 运行时判断 |

**注意**：`game_state`、`event_state`、`event_rounds_elapsed` 是引擎内部使用的条件类型，**不应出现在 completion_conditions 中**（这些是 BehaviorEngine 自动生成的守卫条件，不是管线提取的用户可见条件）。

### 5.4 P3 后处理：unlock_events 自动推导

**原理**：如果事件 B 的 trigger_conditions 包含 `event_triggered(event_A)`，则 A 完成时会解锁 B。这个关系可以自动推导，不需要 LLM 填写。

**实现**：管线最后一步（Phase 3 结束后）：

```python
def _derive_unlock_events(chapters: List[Dict]) -> None:
    """扫描所有事件的 trigger_conditions，推导 on_complete.unlock_events"""
    # 建立事件 ID → 章节 ID 映射
    event_to_chapter = {}
    for ch in chapters:
        for evt in ch.get("events", []):
            event_to_chapter[evt["id"]] = ch["id"]

    # 扫描依赖关系，反向推导 unlock_events
    for ch in chapters:
        for evt in ch.get("events", []):
            trigger = evt.get("trigger_conditions", {})
            for cond in _flatten_conditions(trigger):
                if cond.get("type") == "event_triggered":
                    dep_event_id = cond.get("params", {}).get("event_id", "")
                    if dep_event_id:
                        # 找到被依赖的事件，给它添加 unlock
                        _add_unlock_event(chapters, dep_event_id, evt["id"])
```

### 5.5 P3 后处理：引用完整性校验

```python
def _validate_references(chapters, maps_data, chars_data, items_data) -> List[str]:
    """校验所有引用的合法性，返回警告列表"""
    warnings = []
    valid_areas = {m.id for m in maps_data.maps}
    valid_npcs = {c.id for c in chars_data.characters}

    for ch in chapters:
        for evt in ch.get("events", []):
            # 校验 activation_type=npc_given 时 quest_giver 存在
            if evt.get("activation_type") == "npc_given" and evt.get("quest_giver"):
                if evt["quest_giver"] not in valid_npcs:
                    warnings.append(f"[{evt['id']}] quest_giver '{evt['quest_giver']}' 不存在")

            # 校验条件中的 area_id
            for cond in _flatten_conditions(evt.get("trigger_conditions", {})):
                if cond.get("type") == "location":
                    area_id = cond.get("params", {}).get("area_id", "")
                    if area_id and area_id not in valid_areas:
                        warnings.append(f"[{evt['id']}] location 引用的 area_id '{area_id}' 不存在")

            # 同理校验 npc_interacted、quest_giver 等...

    return warnings
```

---

## 六、条件类型快速参考（供 prompt 设计）

### 可在 trigger_conditions / completion_conditions 中使用

| type | params | 语义 | 适用场景 |
|------|--------|------|---------|
| `event_triggered` | `{"event_id": "..."}` | 某事件已完成 | 顺序依赖链 |
| `location` | `{"area_id": "...", "sub_location": "..."(可选)}` | 玩家在指定地点 | 进入触发、地点任务 |
| `npc_interacted` | `{"npc_id": "...", "min_interactions": 1}` | 与NPC交互N次 | 对话推进条件 |
| `party_contains` | `{"character_id": "..."}` | 队伍含某角色 | 需要特定同伴 |
| `rounds_elapsed` | `{"min_rounds": N, "max_rounds": M}` | 章节经过N-M回合 | 时间触发 |
| `time_passed` | `{"min_day": N, "min_hour": H}` | 游戏时间到达 | 日程/时间事件 |
| `flash_evaluate` | `{"prompt": "判断问题"}` | LLM语义判断 | 主观/模糊条件 |

### 不应在管线中生成（引擎内部用）

- `event_state` — 引擎状态守卫，BehaviorEngine 自动生成
- `event_rounds_elapsed` — 超时/冷却计时，BehaviorEngine 自动生成
- `game_state` — 当前 game_state 字段永远为空字符串，无效
- `objective_completed` — 章节级目标，用于 chapter transitions，不用于事件内部

---

## 七、XP 参考值（供 on_complete.add_xp）

| 事件类型 | XP 建议范围 | 说明 |
|---------|-----------|------|
| 章节开启/铺垫（flavor） | 50-100 | 纯氛围事件 |
| 对话调查推进（side） | 100-200 | 普通支线任务 |
| 主线推进节点（main） | 200-400 | 关键剧情推进 |
| 重大战斗/BOSS 战 | 400-800 | 具有挑战性的战斗 |
| 章节终结/重大转折 | 600-1000 | 章节收官事件 |
| 个人成长/角色事件（personal） | 50-150 | 角色间互动 |

---

## 八、当前管线改造任务清单

| 任务 | 类型 | 优先级 | 影响范围 |
|------|------|--------|---------|
| Phase 1 新增 `_full_content` 字段 | 代码 | P0 | 修复两层截断问题 |
| 新 prompt `chapter_orchestration_v2.md` | Prompt | P0 | 核心，决定提取质量 |
| Phase 3 使用 `_full_content` 替代截断描述 | 代码 | P0 | 联动上面两项 |
| 新增 `{known_items}` 上下文变量 | 代码 | P1 | 补充奖励参考 |
| `_apply_orchestration()` 处理新字段 | 代码 | P1 | stages/outcomes/activation_type 等 |
| `_derive_unlock_events()` 后处理 | 代码 | P1 | 自动推导解锁关系 |
| `_validate_references()` 校验 | 代码 | P2 | 数据质量保障 |
| 小批量验证（Direct 模式，1 卷） | 测试 | P1 | 验证 prompt 效果 |

---

> **下一步**：基于本规格书设计 `chapter_orchestration_v2.md` prompt，重点覆盖 completion_conditions / on_complete / activation_type / stages / outcomes 的提取规则。
