# 阶段 4 执行准备

> 本文档是阶段 4 实施前的详细设计。★ 问题已全部拍板。

---

## 已确认决策

| 编号 | 决策 | 结论 |
|------|------|------|
| Q1 | GM 角色 | 有限视角，保留实用工具 + **持久化记忆**（记住玩家行为/偏好） |
| Q2 | NPC Agentic | 全 Agentic，按角色/职能配有限工具集 |
| Q3 | 翻译层 | Path B: MCP 兼容格式定义 + 进程内执行（未来可拆为真 MCP Server） |
| Q4 | 私聊 | 独立管线，效果（记忆/好感度/反应）走正常流程 |
| Q5 | 旧事件 | 删除旧系统，3 条 trigger_event 旧路径全改调 SessionRuntime |
| Q6 | 接触制 | 前端点击交互触发 contact，结束对话 end_contact，子地点切换清空 |
| P1 | GM 事件工具 | **P1-C 混合**：激活靠玩家 UI 点击，完成靠 GM 叙事收尾 |
| P2 | NPC 对话时 GM | **多 Agent 并行自主决策**：NPC 必答，GM/队友自主决策是否发言 |
| P3 | 子地点切换 | **P3-B 清空**：子地点切换清空临时成员 |
| 新 | Agentic Loop | 统一 AgenticExecutor（GM/NPC/队友共用执行器） |
| 新 | NPC 反应模式 | 被动触发（玩家点击 → NPC 进入总线 → NPC Agentic 响应） |
| 新 | NPC 必答 | NPC 始终回复，好感度影响态度/长度，不影响是否回答 |
| 新 | 对话选项 | 每轮回复后 GM 快速生成 4 个选项，选项即玩家消息 |
| 新 | GM 记忆 | GM 有 ContextWindow + GM 图谱（记录对玩家的观察/偏好/伏笔） |
| 新 | 统一记忆模型 | 所有 Agent 共用：ContextWindow (~128K) + 角色图谱（长期），满了压缩入图 |
| 新 | Recall scope | 按角色配不同 scope：NPC(角色+地点)、队友(角色+阵营+地点)、GM(GM图+区域+章节) |
| 新 | GM 工具大清洗 | 现有 22 个工具 → 9 个（基础 5 + 专属 4），删除所有机械操作和 npc_dialogue |

---

## 一、交互模型全景

先看全貌——前端怎么触发、后端怎么处理：

```
┌──────────────────────────────────────────────────────────┐
│  前端（点击驱动）                                          │
│                                                          │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐  │
│  │ 与酒保交谈 │  │ 查看公告板 │  │ 前往森林  │  │ 自由输入 │  │
│  └─────┬────┘  └─────┬────┘  └─────┬────┘  └────┬────┘  │
└────────┼─────────────┼─────────────┼────────────┼────────┘
         ▼             ▼             ▼            ▼
    NPC 对话流      查看/检查流     导航流      主 Pipeline
    (新 D5 流程)    (纯查询)      (IntentExec)  (现有 A/B/C)
```

### NPC 对话流（阶段 4 核心新增）

```
玩家点击"与酒保交谈"
  │
  ├─ 1. SceneBus.contact("bartender_01")       // 酒保加入总线
  ├─ 2. 玩家消息 → SceneBus.publish()
  │
  ├─ 3. 并行 Agent 响应:
  │     ┌──────────────────────────────────────────────────┐
  │     │ NPC (必答)         GM (自主决策)     队友 (自主决策) │
  │     │ 思维链 → 回复      思维链 → 叙述     思维链 → 插嘴   │
  │     │ (好感低→冷淡短句)   or pass          or pass       │
  │     │ 可调用工具:         可调用工具:       可调用工具:     │
  │     │  react_to_..        share_thought    react_to_..   │
  │     │  recall_experience  notice_something recall_..     │
  │     │  evaluate_offer     form_impression  express_need  │
  │     └──────────────────────────────────────────────────┘
  │
  ├─ 4. GM 生成 4 个对话选项（Flash 无 thinking，极快 ~0.5s）
  │     基于: NPC 回复 + 上下文 + 好感度
  │     输出: ["打听委托", "点酒", "问路", "告辞"]
  │
  ├─ 5. SessionRuntime.persist()               // 持久化变更
  └─ 6. 返回：NPC 对话 + GM 叙述(可能) + 队友评论(可能) + 4 选项

玩家选择选项或自由输入 → 作为下一轮消息 → 重复 2-6
玩家点击"结束对话"或导航离开：
  └─ SceneBus.end_contact("bartender_01")      // 酒保离开总线
```

### 主 Pipeline（现有，微调）

自由文本输入仍走现有 A/B/C 管线，但 B 阶段 GM 工具集大幅缩减：
- **删除全部机械工具**：npc_dialogue / heal / damage / add_xp / add_item / remove_item / update_time / update_disposition / activate_event / complete_objective / add_teammate / remove_teammate / disband_party（共 13 个）
- **保留 9 个**：基础 5（recall_experience / form_impression / share_thought / notice_something / report_flash_evaluation）+ 专属 4（generate_scene_image / conclude_quest / advance_chapter / fail_event）
- **GM 定位**：有记忆的氛围叙述者，不直接操纵游戏状态

### 统一 Agent 记忆模型

```
所有 Agent 共用同一记忆架构:

  ContextWindow (~128K)     ──满了──→    MemoryGraphizer     ──→    角色图谱
  (工作记忆, 近期对话)                    (压缩, LLM 提取)           (长期记忆)
                            ◄──recall──  扩散激活检索         ◄──    (GraphScope)

  NPC:     角色图 (character)     recall scope: 角色 + 地点
  队友:    角色图 (character)     recall scope: 角色 + 阵营 + 地点
  GM:      GM 图 (character/gm)   recall scope: GM图 + 区域 + 章节

  GM 图谱存: 对玩家的观察、叙事偏好、伏笔记录、行为模式
```

---

## 二、沉浸式工具清单

> LLM 看到的是左列（角色视角），底层执行的是右列（机械操作）。

### 2.1 基础工具（所有 Agent 共享）

| 工具 | LLM 视角描述 | 参数 | 底层映射 |
|------|-------------|------|---------|
| `react_to_interaction` | 表达你对这次互动的感受 | `dimension`: approval/trust/fear/romance | SessionRuntime.update_disposition() |
| | | `level`: slight/moderate/strong | 经 FEELING_MAP 翻译 |
| | | `is_positive`: bool | |
| | | `reason`: 角色视角自由文本 | |
| `share_thought` | 说出、低语或在心中想 | `thought`: 内容 | SceneBus.publish(BusEntry) |
| | | `visibility`: spoken/whispered/internal | spoken=公开, whispered=nearby, internal=不发布 |
| `recall_experience` | 回忆与话题相关的经历 | `topic`: 关键词 | RecallOrchestrator.recall() |
| | | `context`: 当前情境描述 | 扩散激活检索 |
| `form_impression` | 对某人/某事形成印象 | `about`: 对象 | GraphStore.upsert_node() |
| | | `impression`: 印象内容 | 写入角色记忆图谱 |
| | | `significance`: low/medium/high | 影响节点权重 |
| `notice_something` | 注意到周围的变化 | `observation`: 观察内容 | SceneBus.publish(REACTION) |
| | | `reaction`: 内心/外在反应 | |

### 2.2 GM 专属工具

| 工具 | 描述 | 底层映射 |
|------|------|---------|
| `generate_scene_image` | 为当前场景生成插图 | ImageGenerationService |
| `conclude_quest` | 叙述任务结局（条件满足后盖章） | SessionRuntime.complete_event() |
| `advance_chapter` | 推进章节 | SessionRuntime.advance_chapter() |
| `fail_event` | 判定任务失败 | SessionRuntime.fail_event() |
| `report_flash_evaluation` | BehaviorEngine 语义评估回报 | session.flash_results |

> 注：事件激活由**玩家 UI 点击**触发（P1-C），GM 不需要 activate_event。
> GM 也使用基础工具中的 recall_experience / form_impression / share_thought / notice_something。

### 2.3 NPC 特化工具（按 trait 分配）

| trait | 额外工具 | 描述 | 底层映射 |
|-------|---------|------|---------|
| `merchant` | `evaluate_offer` | 评估顾客提出的交易 | ShopManager.check_price() |
| | `propose_deal` | 提议一笔买卖 | ShopManager.transact() |
| | `adjust_my_prices` | 因为某个原因调整价格 | ShopNode.state.price_modifiers |
| `guard` | `grant_passage` | 允许/拒绝通行 | AreaNode.state.access_flags |
| `quest_giver` | `offer_quest` | 向冒险者提供任务 | SessionRuntime.activate_event() |
| `healer` | `offer_healing` | 治疗来访者 | SessionRuntime.heal() |

### 2.4 队友专属工具

| 工具 | 描述 | 底层映射 |
|------|------|---------|
| `express_need` | 表达需求或担忧 | SceneBus.publish(hint) |
| `choose_battle_action` | 战斗中选择行动 | CombatEngine (经 MCP) |
| `assess_situation` | 评估当前战况 | CombatState 查询 |

### 2.5 翻译层（FEELING_MAP）

```python
FEELING_MAP = {
    # (dimension,   level,      positive) → deltas
    ("approval",  "slight",    True):   {"approval": +5},
    ("approval",  "moderate",  True):   {"approval": +10},
    ("approval",  "strong",    True):   {"approval": +20},
    ("approval",  "slight",    False):  {"approval": -5},
    ("approval",  "moderate",  False):  {"approval": -10},
    ("approval",  "strong",    False):  {"approval": -20},
    ("trust",     "slight",    True):   {"trust": +5},
    ("trust",     "moderate",  True):   {"trust": +10},
    ("trust",     "strong",    True):   {"trust": +20},
    ("trust",     "slight",    False):  {"trust": -5},
    ("trust",     "moderate",  False):  {"trust": -10},
    ("trust",     "strong",    False):  {"trust": -20},
    ("fear",      "slight",    True):   {"fear": +5},
    ("fear",      "moderate",  True):   {"fear": +10},
    ("fear",      "strong",    True):   {"fear": +20},
    ("fear",      "slight",    False):  {"fear": -5},
    ("fear",      "moderate",  False):  {"fear": -10},
    ("fear",      "strong",    False):  {"fear": -20},
    ("romance",   "slight",    True):   {"romance": +5},
    ("romance",   "moderate",  True):   {"romance": +10},
    ("romance",   "strong",    True):   {"romance": +20},
    ("romance",   "slight",    False):  {"romance": -5},
    ("romance",   "moderate",  False):  {"romance": -10},
    ("romance",   "strong",    False):  {"romance": -20},
}
```

---

## 三、统一 AgenticExecutor 设计

替代现有 3 套独立实现（FlashCPU.agentic_process_v4 / TeammateResponseService / NPCReactor）。

### 3.1 接口

```python
class AgenticExecutor:
    """统一 Agent 执行器 — 所有角色共用一个 Agentic Loop。"""

    def __init__(self, llm_service: LLMService):
        self.llm = llm_service

    async def run(
        self,
        *,
        agent_id: str,              # "gm" | npc_id | teammate_id
        role: str,                  # "gm" | "npc" | "teammate"
        traits: List[str],          # ["merchant", "guard", ...]
        system_prompt: str,         # 角色专属系统提示
        context: Dict[str, Any],    # 上下文（按角色裁剪）
        session: SessionRuntime,    # 世界状态入口
        scene_bus: SceneBus,        # 当前场景总线
        event_queue: Optional[asyncio.Queue] = None,
        model_override: Optional[str] = None,
        thinking_level: Optional[str] = None,
        max_tool_rounds: int = 5,
    ) -> AgenticResult:
        # 1. 获取工具集
        tools = RoleRegistry.get_tools(role, traits, session, agent_id)

        # 2. 组装 user prompt（上下文 + 场景总线摘要）
        user_prompt = self._build_prompt(context, scene_bus, agent_id)

        # 3. 调用 LLM agentic loop
        response = await self.llm.agentic_generate(
            system_instruction=system_prompt,
            user_prompt=user_prompt,
            tools=tools,
            model_override=model_override,
            thinking_level=thinking_level,
            max_remote_calls=max_tool_rounds,
        )

        # 4. 提取文本 + 工具调用记录
        return AgenticResult(
            narration=response.text,
            tool_calls=self._extract_tool_calls(response),
            agent_id=agent_id,
            role=role,
        )
```

### 3.2 调用方式对比

| 角色 | 现在怎么调 | 改造后怎么调 |
|------|-----------|-------------|
| GM | `FlashCPU.agentic_process_v4(session, context, ...)` | `executor.run(agent_id="gm", role="gm", ...)` |
| 队友 | `FlashCPU.agentic_generate(tools=teammate_tools, ...)` | `executor.run(agent_id=member.character_id, role="teammate", ...)` |
| NPC | `LLMService.generate_simple()` (无工具) | `executor.run(agent_id=npc_id, role="npc", traits=[...], ...)` |

### 3.3 记录与 SSE 推送

工具调用的 `_record()` + SSE 推送逻辑从 V4AgenticToolRegistry 移入 AgenticExecutor：
- 每次工具调用 → `event_queue.put({"type": "tool_call", ...})`
- 好感度变更 → 额外推送 `disposition_change` 事件
- NPC 对话 → 推送 `npc_response` 事件

---

## 四、RoleRegistry 设计

### 方案 A：装饰器注册（推荐）

```python
# === app/world/immersive_tools.py ===

_TOOL_REGISTRY: Dict[str, ToolDef] = {}

@dataclass
class ToolDef:
    fn: Callable
    roles: Set[str]      # 哪些角色可用，空集 = 所有角色
    traits: Set[str]     # 需要哪些 trait（空 = 无限制）
    description: str     # 角色视角描述（给 LLM 看）

def immersive_tool(*, roles: List[str] = [], traits: List[str] = [], desc: str = ""):
    """注册一个沉浸式工具。"""
    def decorator(fn):
        _TOOL_REGISTRY[fn.__name__] = ToolDef(
            fn=fn, roles=set(roles), traits=set(traits), description=desc,
        )
        return fn
    return decorator

# --- 工具定义 ---

@immersive_tool(desc="Express how you feel about this interaction")
async def react_to_interaction(
    session: SessionRuntime, agent_id: str,
    dimension: str, level: str, is_positive: bool, reason: str,
) -> Dict[str, Any]:
    deltas = FEELING_MAP.get((dimension, level, is_positive))
    if not deltas:
        return {"success": False, "error": f"unknown feeling: {dimension}/{level}"}
    return session.update_disposition(npc_id=agent_id, deltas=deltas, reason=reason)

@immersive_tool(traits=["merchant"], desc="Evaluate a customer's offer")
async def evaluate_offer(
    session: SessionRuntime, agent_id: str,
    item: str, customer_impression: str,
) -> Dict[str, Any]:
    ...

# === app/world/role_registry.py ===

class RoleRegistry:
    @staticmethod
    def get_tools(
        role: str,
        traits: List[str],
        session: SessionRuntime,
        agent_id: str,
    ) -> List[Callable]:
        """返回该角色可用的工具列表（已绑定 session + agent_id）。"""
        result = []
        trait_set = set(traits)
        for name, defn in _TOOL_REGISTRY.items():
            # 角色过滤
            if defn.roles and role not in defn.roles:
                continue
            # Trait 过滤
            if defn.traits and not (defn.traits & trait_set):
                continue
            # 绑定 session 和 agent_id（LLM 不需要传这两个参数）
            bound = functools.partial(defn.fn, session=session, agent_id=agent_id)
            bound.__name__ = name
            bound.__doc__ = defn.description
            bound.__annotations__ = _strip_internal_params(defn.fn.__annotations__)
            result.append(bound)
        return result
```

**优点**：
- 工具定义即注册，一处修改
- `roles` + `traits` 双维度过滤
- `functools.partial` 隐藏 session/agent_id，LLM 只看到业务参数
- 新增角色/trait 只需改装饰器参数

### 方案 B：配置驱动

```python
ROLE_TOOLS = {
    "gm": ["generate_scene_image", "introduce_event", "conclude_quest"],
    "npc": ["react_to_interaction", "share_thought", "recall_experience",
            "form_impression", "notice_something"],
    "teammate": ["react_to_interaction", "share_thought", "recall_experience",
                 "form_impression", "express_need", "notice_something"],
}

TRAIT_TOOLS = {
    "merchant": ["evaluate_offer", "propose_deal", "adjust_my_prices"],
    "guard": ["grant_passage"],
    "quest_giver": ["offer_quest"],
    "healer": ["offer_healing"],
    "combat": ["choose_battle_action", "assess_situation"],
}
```

**优点**：一眼看全貌，非程序员也能改
**缺点**：工具名是字符串，重命名容易遗漏

### 建议

**方案 A + 方案 B 混合**：用装饰器注册保证类型安全，额外导出一份 `ROLE_TOOLS` / `TRAIT_TOOLS` 字典用于文档和调试。

---

## 五、SceneBus 成员模型设计

### 方案 A：最小改动（推荐）

在现有 SceneBus 上新增 3 个字段 + 3 个方法：

```python
class SceneBus:
    # 现有字段保留
    area_id: str
    sub_location: Optional[str]
    round_number: int
    _entries: List[BusEntry]

    # ── 新增 ──
    permanent_members: Set[str]    # player + teammate IDs
    active_members: Set[str]       # 当前对话中的 NPC IDs

    def contact(self, npc_id: str) -> None:
        """玩家开始与 NPC 交互 → NPC 加入总线。"""
        self.active_members.add(npc_id)

    def end_contact(self, npc_id: str) -> None:
        """玩家结束与 NPC 交互 → NPC 离开总线。"""
        self.active_members.discard(npc_id)

    def is_member(self, entity_id: str) -> bool:
        return entity_id in self.permanent_members or entity_id in self.active_members

    def get_members(self) -> Set[str]:
        return self.permanent_members | self.active_members

    # 现有 reset 改造
    def reset_scene(self, new_area_id: str) -> None:
        """区域切换 → 清临时成员 + 条目，保留常驻成员。"""
        self.area_id = new_area_id
        self.sub_location = None
        self.active_members.clear()
        self._entries.clear()

    # 现有 get_visible_entries 增强
    def get_visible_entries(self, viewer_id: Optional[str] = None) -> List[BusEntry]:
        if viewer_id and not self.is_member(viewer_id):
            return []  # 非成员看不到任何内容
        # ... 现有 visibility 逻辑 ...
```

**生命周期**：

```
进入区域 → SceneBus(area_id, permanent_members={player, tm1, tm2})
  │
  ├─ 玩家点击"与酒保交谈" → contact("bartender")
  │   ├─ 对话回合 1: 酒保在总线上，可感知所有条目
  │   ├─ 对话回合 2: 队友插嘴，酒保看到
  │   └─ 玩家点击"结束对话" → end_contact("bartender")
  │
  ├─ 玩家点击"与铁匠交谈" → contact("blacksmith")
  │   └─ ...
  │
  └─ 玩家导航到森林 → reset_scene("forest")
      active_members 清空，permanent_members 保留
```

**改动量**：~30 行

### 方案 B：成员对象 + 生命周期事件

```python
@dataclass
class BusMember:
    entity_id: str
    name: str
    role: str           # "player" | "teammate" | "npc"
    joined_at: str      # game time
    is_permanent: bool

class SceneBus:
    _members: Dict[str, BusMember]     # entity_id → BusMember
    _entries: List[BusEntry]

    def contact(self, npc_id: str, name: str) -> BusMember:
        member = BusMember(entity_id=npc_id, name=name, role="npc", ...)
        self._members[npc_id] = member
        self.publish(BusEntry(
            actor="system", type=SYSTEM,
            content=f"{name} 注意到了你的到来",
        ))
        return member

    def end_contact(self, npc_id: str) -> None:
        member = self._members.pop(npc_id, None)
        if member and not member.is_permanent:
            self.publish(BusEntry(
                actor="system", type=SYSTEM,
                content=f"你离开了 {member.name}",
            ))
```

**优点**：加入/离开事件可见，更沉浸
**缺点**：多 ~60 行，BusMember 序列化需处理

### 建议

**先方案 A**，验证流程跑通后，按需升级到方案 B。

---

## 六、私聊管线设计

### 需求回顾

- 主要用于**队友 1v1 私聊**
- 队友使用沉浸式工具（`react_to_interaction` / `recall_experience` / `form_impression`）
- 产生的效果（好感度、记忆）**正常持久化**
- 不触发 GM 叙述、不触发其他 NPC/队友反应、不触发事件引擎

### 方案 A：PipelineOrchestrator 内部分支

```python
# pipeline_orchestrator.py
async def process(self, ..., is_private=False, private_target=None):
    if is_private and private_target:
        return await self._process_private_chat(
            session, player_input, private_target, event_queue
        )
    # ... 正常 A/B/C 流程 ...

async def _process_private_chat(self, session, message, target_id, event_queue):
    # A-lite: 恢复 session + 加载目标角色信息
    # B: AgenticExecutor.run(target_id, role="teammate", tools=...)
    # C-lite: persist + record history
```

**优点**：共享 session 生命周期代码
**缺点**：主 pipeline 类职责增加

### 方案 B：独立 PrivateChatPipeline（推荐）

```python
class PrivateChatPipeline:
    """队友私聊管线 — 精简版，效果走正常流程。"""

    def __init__(self, executor: AgenticExecutor, ...):
        self.executor = executor

    async def process(
        self,
        world_id: str,
        session_id: str,
        target_id: str,
        message: str,
        event_queue: Optional[asyncio.Queue] = None,
    ) -> PrivateChatResponse:

        # ── A. 准备 ──
        session = SessionRuntime(world_id, session_id, ...)
        await session.restore()

        # 目标必须是队友
        member = session.party.get_member(target_id)
        if not member:
            return PrivateChatResponse(error="目标不在队伍中")

        # ── B. Agent 响应 ──
        # 组装精简上下文（只有队友 profile + 近期对话 + 好感度）
        context = self._build_private_context(session, member, message)

        result = await self.executor.run(
            agent_id=target_id,
            role="teammate",
            traits=self._get_traits(member),
            system_prompt=self._load_private_prompt(member),
            context=context,
            session=session,
            scene_bus=session.scene_bus,  # 私聊条目标记 visibility="private:{target_id}"
            event_queue=event_queue,
        )

        # ── C. 持久化 ──
        # 好感度变更已通过 react_to_interaction → SessionRuntime 写入
        # 记忆已通过 form_impression → GraphStore 写入
        session.history.record_private_chat(target_id, message, result.narration)
        await session.persist()

        return PrivateChatResponse(
            character_id=target_id,
            name=member.name,
            response=result.narration,
            tool_calls=result.tool_calls,
        )
```

**优点**：
- 职责清晰，独立可测
- 不污染主 pipeline
- 共享 AgenticExecutor + SessionRuntime

**缺点**：session 生命周期代码轻微重复（可提取 BasePipeline）

### 方案 C：共享基类

```python
class BasePipeline:
    async def setup_session(self, world_id, session_id) -> SessionRuntime:
        session = SessionRuntime(...)
        await session.restore()
        return session

    async def teardown(self, session: SessionRuntime) -> None:
        await session.persist()

class MainPipeline(BasePipeline):
    async def process(self, ...) -> CoordinatorResponse: ...

class PrivateChatPipeline(BasePipeline):
    async def process(self, ...) -> PrivateChatResponse: ...
```

**优点**：最干净，零重复
**缺点**：需重构现有 PipelineOrchestrator（改动大）

### 建议

**先方案 B**（独立类，快速上线），后期如有更多管线类型再提取 BasePipeline。

---

## 七、执行分段

```
Phase 4a: 基础设施               Phase 4b: Agent 改造           Phase 4c: 清理 + 新功能
┌─────────────────────┐     ┌──────────────────────┐     ┌────────────────────┐
│ SceneBus 成员模型    │     │ 沉浸式工具实现        │     │ D12 旧事件删除      │
│ RoleRegistry 骨架    │ ──→ │ AgenticExecutor      │ ──→ │ MCP/REST 废弃清理   │
│ FEELING_MAP 翻译层   │     │ NPC 对话流改造        │     │ 私聊管线 (D11)      │
│ 工具定义 (无实现)     │     │ 队友系统接入          │     │ 回合时间 (D9)       │
└─────────────────────┘     │ GM 工具集缩减         │     └────────────────────┘
     ~200 行                 └──────────────────────┘          ~300 行
                                  ~500 行
```

### 4a 详细任务

| # | 任务 | 文件 | 预估 |
|---|------|------|------|
| 1 | SceneBus 新增 permanent_members / active_members / contact / end_contact / reset_scene | scene_bus.py | +30 行 |
| 2 | SessionRuntime._init_scene_bus() 传入 permanent_members；子地点切换清空临时成员 | session_runtime.py | +10 行 |
| 3 | immersive_tools.py — 工具定义 + FEELING_MAP + 装饰器注册 | 新文件 | +150 行 |
| 4 | role_registry.py — RoleRegistry.get_tools() | 新文件 | +50 行 |
| 5 | RecallOrchestrator 新增 role 参数，按角色配 scope | recall_orchestrator.py | +30 行 |
| 6 | GM 图谱 scope 建立 (GraphScope.character("gm_{session_id}")) | 无代码改动（scope 机制已支持） | 0 行 |
| 7 | 测试：SceneBus 成员 + RoleRegistry 过滤 + Recall scope | 新测试 | +120 行 |

### 4b 详细任务

| # | 任务 | 文件 | 预估 |
|---|------|------|------|
| 6 | AgenticExecutor 类（统一 agentic loop） | 新文件 | +120 行 |
| 7 | NPC 对话流 — 新 REST 端点 `POST /interact` | game_v2.py + orchestrator | +100 行 |
| 8 | NPCReactor 改造 — 移除自主反应，改为被动触发 | npc_reactor.py | ~重写 |
| 9 | TeammateResponseService 接入 AgenticExecutor | teammate_response_service.py | ~-200 行 |
| 10 | GM 工具集缩减 — 移除机械工具，改用沉浸式基础工具 | v4_agentic_tools.py | ~-300 行 |
| 11 | FlashCPU.agentic_process_v4 改调 AgenticExecutor | flash_cpu_service.py | ~重构 |

### 4c 详细任务

| # | 任务 | 文件 | 预估 |
|---|------|------|------|
| 12 | D12: 删除 NarrativeService.trigger_event + 3 条旧路径 | 多文件 | ~-200 行 |
| 13 | MCP 废弃工具删除（character/inventory/graph/time/narrative） | mcp/tools/*.py | ~-300 行 |
| 14 | AdminCoordinator/WorldRuntime 旁路方法删除 | admin 目录 | ~-100 行 |
| 15 | PrivateChatPipeline 实现 (D11) | 新文件 | +150 行 |
| 16 | D9 回合时间系统（每轮 +10min） | session_runtime.py | +30 行 |
| 17 | 队友好感度改走 SessionRuntime | teammate_agentic_tools.py | ~-50 行 |

---

## 已拍板问题记录

| 问题 | 结论 | 理由 |
|------|------|------|
| P1. GM 事件工具 | **P1-C 混合** | 激活靠玩家 UI（点击驱动），完成靠 GM 叙事收尾（`conclude_quest` 验证条件后才执行，是"盖章"不是"决定"） |
| P2. NPC 对话时 GM | **多 Agent 并行** | NPC 必答（好感低→冷淡短句），GM+队友自主决策是否发言（思维链判断），每轮后 GM 快速生成 4 选项 |
| P3. 子地点切换 | **P3-B 清空** | 子地点切换 = 移动，NPC 不跟随。目标子地点的 NPC 可重新 contact |
| 图谱 recall scope | **按角色配** | NPC(角色+地点)、队友(角色+阵营+地点)、GM(GM图+区域+章节)，详见「图谱系统审视与改进方向.md」 |

---

## 4a 实施发现（4b 待处理）

| # | 发现 | 位置 | 处置 | 时机 |
|---|------|------|------|------|
| 1 | `recall_v4()` 被 `recall_for_role()` 取代 | `recall_orchestrator.py:225-323` | 切换调用方后删除 | 4b |
| 2 | recall 三方法共享 ~30 行重复代码（种子扩展 + activation + subgraph） | `recall_orchestrator.py` | 提取 `_activate_and_extract()` helper | 4b |
| 3 | SessionRuntime permanent_members 计算重复 | `session_runtime.py:395-398` 和 `902-905` | 提取 `_get_permanent_bus_members()` | 低优先 |
| 4 | `_wrap_tool_for_afc()` 与 `bind_tool()` 模式重叠 | `v4_agentic_tools.py:86-120` vs `immersive_tools.py` | AgenticExecutor 统一后用 bind_tool 替代 | 4b |

---

## 变更日志

| 日期 | 操作 |
|------|------|
| 2026-02-21 | 创建：基于大调查结果 + 用户决策，完成执行准备文档 |
| 2026-02-21 | 更新：P1/P2/P3 全部拍板；新增 GM 持久化记忆、统一记忆模型、按角色 recall scope、GM 工具大清洗(22→9)、多 Agent 并行对话模型、每轮 4 选项生成、NPC 必答机制；4a 任务加入 recall scope 改造 + GM 图谱 |
| 2026-02-21 | **4a 完成**：SceneBus 成员模型、immersive_tools.py(19 工具+FEELING_MAP+bind_tool)、role_registry.py、recall_for_role()、30 个测试全通过；记录 4 项实施发现供 4b 处理 |
