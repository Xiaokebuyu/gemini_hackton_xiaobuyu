"""
Diagnostic tests for agentic tool schema generation.

Validates that all 22 tools exposed by AgenticToolRegistry can have their
FunctionDeclaration generated by the Gemini SDK without errors.
"""
import inspect
import types
from typing import get_type_hints
from unittest.mock import AsyncMock

import pytest

from app.services.admin.agentic_tools import AgenticToolRegistry


def _make_registry() -> AgenticToolRegistry:
    """Build a minimal registry with a stub flash_cpu."""
    flash_cpu = types.SimpleNamespace(
        state_manager=types.SimpleNamespace(
            get_state=AsyncMock(return_value=None),
        ),
        session_store=types.SimpleNamespace(
            get_session=AsyncMock(return_value=None),
        ),
    )
    return AgenticToolRegistry(
        flash_cpu=flash_cpu,
        world_id="test_world",
        session_id="test_session",
    )


EXPECTED_TOOL_NAMES = [
    "recall_memory",
    "navigate",
    "update_time",
    "enter_sublocation",
    "npc_dialogue",
    "start_combat",
    "get_combat_options",
    "choose_combat_action",
    "trigger_narrative_event",
    "get_progress",
    "get_status",
    "add_teammate",
    "remove_teammate",
    "disband_party",
    "heal_player",
    "damage_player",
    "add_xp",
    "add_item",
    "remove_item",
    "ability_check",
    "evaluate_story_conditions",
    "generate_scene_image",
]


class TestToolRegistration:
    """Verify that get_tools() returns the correct number and names."""

    def test_tool_count(self):
        registry = _make_registry()
        tools = registry.get_tools()
        assert len(tools) == 22, f"Expected 22 tools, got {len(tools)}"

    def test_tool_names(self):
        registry = _make_registry()
        tools = registry.get_tools()
        names = [t.__name__ for t in tools]
        assert names == EXPECTED_TOOL_NAMES

    def test_all_tools_are_coroutines(self):
        registry = _make_registry()
        for tool in registry.get_tools():
            assert inspect.iscoroutinefunction(tool), (
                f"{tool.__name__} is not a coroutine function"
            )


class TestSchemaGeneration:
    """Test that each tool's type annotations are compatible with SDK schema generation."""

    def test_all_tools_have_type_hints(self):
        registry = _make_registry()
        for tool in registry.get_tools():
            hints = get_type_hints(tool)
            assert "return" in hints, (
                f"{tool.__name__} missing return type annotation"
            )

    def test_no_any_in_parameter_annotations(self):
        """Ensure no tool uses bare `Any` in parameter type hints (breaks SDK schema)."""
        from typing import Any
        registry = _make_registry()
        violations = []
        for tool in registry.get_tools():
            hints = get_type_hints(tool)
            sig = inspect.signature(tool)
            for param_name, param in sig.parameters.items():
                if param_name == "self":
                    continue
                hint = hints.get(param_name)
                if hint is Any:
                    violations.append(f"{tool.__name__}.{param_name}: Any")
        assert not violations, (
            f"Parameters with bare `Any` type (breaks SDK schema): {violations}"
        )

    def test_start_combat_uses_list_dict(self):
        """Verify start_combat no longer uses List[Any]."""
        registry = _make_registry()
        hints = get_type_hints(registry.start_combat)
        enemies_hint = hints.get("enemies")
        assert enemies_hint is not None
        # Should be list[dict] (Python 3.9+ built-in generic)
        origin = getattr(enemies_hint, "__origin__", None)
        assert origin is list, f"Expected list, got {enemies_hint}"
        args = getattr(enemies_hint, "__args__", ())
        assert len(args) == 1 and args[0] is dict, (
            f"Expected list[dict], got list[{args}]"
        )

    @pytest.mark.parametrize("tool_name", EXPECTED_TOOL_NAMES)
    def test_tool_has_docstring(self, tool_name: str):
        """Each tool should have a docstring for SDK description extraction."""
        registry = _make_registry()
        tool = getattr(registry, tool_name)
        assert tool.__doc__, f"{tool_name} is missing a docstring"

    def test_sdk_function_declaration_compatibility(self):
        """Attempt to build FunctionDeclaration from each tool callable.

        This test imports the Gemini SDK and calls the schema builder.
        If the SDK is not installed, the test is skipped.

        Note: FunctionDeclaration.from_callable requires a `client` arg in
        newer SDK versions. We create a minimal client for schema generation.
        """
        try:
            from google.genai.types import FunctionDeclaration
            from google.genai import Client
        except ImportError:
            pytest.skip("google-genai SDK not installed")

        # Create a client with a dummy key â€” only used for schema parsing,
        # no actual API calls are made.
        client = Client(api_key="dummy-key-for-schema-test")

        registry = _make_registry()
        failures = []
        for tool in registry.get_tools():
            try:
                fd = FunctionDeclaration.from_callable(
                    callable=tool, client=client._api_client
                )
                assert fd.name == tool.__name__
            except Exception as exc:
                failures.append(f"{tool.__name__}: {type(exc).__name__}: {exc}")

        assert not failures, (
            f"FunctionDeclaration build failures:\n" +
            "\n".join(f"  - {f}" for f in failures)
        )


class TestEnforcementNameMapping:
    """Verify that tool __name__ attributes map correctly through the enforcement system."""

    def test_record_uses_flash_operation_value(self):
        """The _record method receives FlashOperation.value as name,
        which should match enforcement's SIDE_EFFECT_TOOLS / READ_ONLY_TOOLS."""
        from app.services.admin.agentic_enforcement import (
            READ_ONLY_TOOLS,
            SIDE_EFFECT_TOOLS,
            REPAIR_NAME_MAP,
        )
        from app.models.admin_protocol import FlashOperation

        all_enforcement_tools = READ_ONLY_TOOLS | SIDE_EFFECT_TOOLS
        all_ops = {op.value for op in FlashOperation}

        # Every FlashOperation value used in tools should be in enforcement sets
        # (except SPAWN_PASSERBY which is not in agentic tools)
        agentic_ops = all_ops - {"spawn_passerby"}
        for op in agentic_ops:
            assert op in all_enforcement_tools, (
                f"FlashOperation.{op} not found in enforcement tool sets"
            )

    def test_repair_name_map_covers_all_enforcement_tools(self):
        from app.services.admin.agentic_enforcement import (
            READ_ONLY_TOOLS,
            SIDE_EFFECT_TOOLS,
            REPAIR_NAME_MAP,
        )

        all_tools = READ_ONLY_TOOLS | SIDE_EFFECT_TOOLS
        for tool_name in all_tools:
            assert tool_name in REPAIR_NAME_MAP, (
                f"{tool_name} not in REPAIR_NAME_MAP"
            )
