# 世界活图 (WorldGraph) — 详细设计

> 日期: 2026-02-13
> 分支: buyu的异世界冒险
> 前置文档: `队友Agent化与世界活图计划.md` Phase C
> 状态: C1-C6 已实施，C7 待实施

---

## 〇、设计理念

**从平面图到三维图世界**：

```
当前（平面）:
  MemoryNode = 被动数据容器
  GraphScope = Firestore 路径约定
  AreaRuntime = 图之外的独立事件状态机
  图的唯一用途 = 扩散激活检索记忆

目标（三维）:
  Z 轴 = 层级拓扑（世界 → 章节 → 区域 → 地点），不是路径约定，是真正的图结构
  X/Y 平面 = 每层内的实体关系网络（NPC、事件、物品）
  深度 = 每个节点有"厚度"——行为(behaviors) / 触发器(triggers) / 可变状态(state)
  事件沿图传播，不需要独立的 EventBus
  图不只是记忆检索工具，而是世界运行的引擎
```

**核心原则**：
1. **图即真理源** — Agent 工具本质上是在操作图节点的 state
2. **统一事件模型** — WorldEvent + node triggers 是一套系统，不是两套
3. **替代 AreaRuntime** — 硬编码事件状态机 → 图上通用行为引擎
4. **渐进式** — WorldInstance 继续负责静态数据加载，WorldGraph 在其上构建行为层

---

## 一、文件结构

```
app/world/
    __init__.py             # 包导出                                    ✅ C1 已实施
    models.py               # WorldNode / Behavior / Action / WorldEvent ✅ C1 已实施
    constants.py            # D&D 5e 参考常量 + 默认 state 模板          ✅ C1 已实施
    world_graph.py          # WorldGraph 核心类（图 + 索引 + 查询）       ✅ C2 已实施
    graph_builder.py        # 从 WorldInstance 数据构建三维图             ✅ C3 已实施
    behavior_engine.py      # 行为评估引擎（tick + 条件评估 + action 执行）✅ C4 已实施
    event_propagation.py    # 事件沿图传播（BFS + 衰减）                  ✅ C5 已实施
    snapshot.py             # 快照序列化 / 反序列化（纯序列化，不含 Firestore I/O）✅ C6 已实施
```

---

## 二、数据模型 (`app/world/models.py`)

> **注意**: 数据模型的完整字段规格、事件生命周期、导航模型详见子文档：
> **`世界图数据模型设计.md`**
> 本章保留概要定义作为快速参考，以子文档为准。
> 子文档新增/修正内容：region 层、多父引用、完整 D&D 5e 角色卡、多阶段任务、
> 分支结局、4 种事件激活方式、地牢线性导航、快速旅行机制、世界模板格式。

### 2.1 触发器类型

```python
class TriggerType(str, Enum):
    """行为触发器类型 — 决定何时评估 behavior 的 conditions。"""
    ON_TICK = "on_tick"                 # 每回合评估（管线 A4/C1 阶段）
    ON_ENTER = "on_enter"               # 实体进入此节点作用域
    ON_EXIT = "on_exit"                 # 实体离开此节点作用域
    ON_EVENT = "on_event"               # 收到传播来的 WorldEvent
    ON_STATE_CHANGE = "on_state_change" # 自身或子节点 state 发生变化
    ON_DISPOSITION = "on_disposition"    # 好感度越过指定阈值
    ON_TIME = "on_time"                 # 游戏时间满足条件
```

### 2.2 行动类型

```python
class ActionType(str, Enum):
    """行为执行的动作类型。"""
    EMIT_EVENT = "emit_event"           # 向图中发射 WorldEvent（会触发传播）
    CHANGE_STATE = "change_state"       # 修改目标节点的 state
    NARRATIVE_HINT = "narrative_hint"   # 注入叙事指令给 LLM（下一轮可见）
    SPAWN = "spawn"                     # 在图中创建新节点（如生成巡逻队）
    REMOVE = "remove"                   # 移除节点（如消耗品用完）
    CHANGE_EDGE = "change_edge"         # 修改边的权重或属性
```

### 2.3 Action

```python
class Action(BaseModel):
    """行为触发后执行的单个动作。"""
    type: ActionType
    target: str = "self"                # 目标节点 ID，特殊值: "self" / "parent" / "player"
    params: Dict[str, Any] = {}
    #
    # params 按 ActionType 不同而异:
    #
    # EMIT_EVENT:
    #   event_type: str          — 事件类型标识
    #   data: Dict               — 事件附带数据
    #   visibility: str          — "local" | "scope" | "global"
    #
    # CHANGE_STATE:
    #   updates: Dict[str, Any]  — 要修改的 state 键值对
    #   merge: bool = True       — True=合并, False=替换整个 state
    #
    # NARRATIVE_HINT:
    #   text: str                — 叙事指令文本
    #   priority: str            — "high" | "normal" | "low"
    #
    # SPAWN:
    #   node: WorldNode (partial) — 要创建的节点模板
    #   parent: str               — 挂载到哪个父节点下
    #
    # REMOVE:
    #   (无额外参数，target 即要删除的节点)
    #
    # CHANGE_EDGE:
    #   source: str / target: str — 边的两端
    #   updates: Dict             — 修改的属性（weight, relation, ...）
```

### 2.4 Behavior

```python
class Behavior(BaseModel):
    """附着在 WorldNode 上的行为定义。"""
    id: str
    trigger: TriggerType

    # ON_EVENT 专用: 只响应特定事件类型
    event_filter: Optional[str] = None          # e.g. "combat_started", "quest_complete"

    # ON_DISPOSITION 专用: 好感度阈值
    disposition_filter: Optional[Dict] = None   # e.g. {"dimension": "trust", "gte": 50}

    # ON_STATE_CHANGE 专用: 监听哪个 state key
    watch_key: Optional[str] = None             # e.g. "status"

    # 条件 — 完全复用现有 ConditionGroup 系统
    # 支持: location / npc_interacted / time_passed / rounds_elapsed /
    #       party_contains / event_triggered / objective_completed /
    #       game_state / flash_evaluate
    conditions: Optional[ConditionGroup] = None

    # 满足条件后执行的动作列表（按顺序执行）
    actions: List[Action]

    # 控制
    priority: int = 0                           # 同一 tick 内多个 behavior 的执行顺序
    once: bool = False                          # True = 触发一次后永久禁用
    cooldown_ticks: int = 0                     # 触发后冷却回合数
    enabled: bool = True                        # 运行时可动态开关

    # 运行时状态（不持久化到 properties，放在 node.state 中）
    # _fired: bool          — once 类型是否已触发
    # _cooldown_remaining   — 剩余冷却回合
```

### 2.5 WorldNode

```python
class WorldNode(BaseModel):
    """三维世界图的节点 — 有行为的实体。"""
    id: str
    type: str                           # chapter / area / location / npc / event_def / item / camp / ...
    name: str
    parent_id: Optional[str] = None     # Z 轴层级父节点（world_root → chapter → area → location）

    # 静态属性 — 从 WorldInstance 加载后不再修改
    properties: Dict[str, Any] = {}

    # 可变运行时状态 — tick/工具调用/behavior 执行可修改
    # 快照时只序列化这部分
    state: Dict[str, Any] = {}

    # 附着的行为列表
    behaviors: List[Behavior] = []
```

**properties vs state 的边界**：

| 类别 | 归属 | 示例 |
|------|------|------|
| 地图描述 | properties | `description`, `atmosphere`, `tags`, `connections` |
| 角色背景 | properties | `personality`, `backstory`, `tier`, `role` |
| 事件定义 | properties | `narrative_directive`, `importance` |
| 章节结构 | properties | `objectives`, `available_maps` |
| 事件状态 | **state** | `status: "locked"/"available"/"active"/"completed"` |
| NPC 情绪 | **state** | `mood: "cheerful"`, `schedule: "resting"` |
| 章节进度 | **state** | `status: "active"`, `started_at: ...` |
| 区域访问 | **state** | `visited: true`, `visit_count: 3` |
| 玩家位置 | **state** | 挂在 player 节点上: `current_location: "loc_guild_hall"` |
| 好感度 | **state** | 挂在 NPC 节点上: `dispositions: {player: {trust: 30, ...}}` |
| 战斗属性 | **state** | 挂在队友/NPC 节点上: `hp: 20, max_hp: 25` |
| 行为冷却 | **state** | `behavior_cooldowns: {bhv_id: 2}` |
| 一次性标记 | **state** | `behavior_fired: ["bhv_id_1", "bhv_id_2"]` |

### 2.6 WorldEvent

```python
class WorldEvent(BaseModel):
    """图内传播的事件。"""
    event_id: str = Field(default_factory=lambda: f"we_{uuid4().hex[:8]}")
    event_type: str                     # combat_started / item_acquired / location_entered / ...
    origin_node: str                    # 事件发生的节点 ID
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    game_day: int = 0
    game_hour: int = 0

    actor: str = ""                     # 发起者（通常 "player"）
    data: Dict[str, Any] = {}           # 事件特定数据

    # 传播控制
    visibility: str = "scope"           # "local"=仅本节点 / "scope"=沿层级传播 / "global"=全图
    strength: float = 1.0               # 初始强度，传播时衰减
    min_strength: float = 0.1           # 低于此阈值停止传播
```

### 2.7 边类型

```python
class WorldEdgeType(str, Enum):
    """图边类型。"""
    # 纵向（Z 轴层级）
    CONTAINS = "contains"               # world → chapter → area → location

    # 横向（同层连接）
    CONNECTS = "connects"               # 区域间通道
    RELATES_TO = "relates_to"           # NPC 间关系
    TRADE_ROUTE = "trade_route"         # 商路（未来扩展）

    # 归属
    HOSTS = "hosts"                     # location → npc（NPC 驻扎）
    HAS_EVENT = "has_event"             # area/location → event_def
    HAS_ITEM = "has_item"              # location/npc → item
    MEMBER_OF = "member_of"             # teammate → camp/party

    # 门控
    GATE = "gate"                       # chapter → chapter（需满足条件才能通过）
```

**边上的属性**（用于传播控制）：

```python
edge_data = {
    "relation": "connects",
    "weight": 1.0,                      # 传播衰减因子（乘以 event.strength）
    "propagation": {
        "up": 0.8,                      # 向上传播（子→父）衰减
        "down": 0.6,                    # 向下传播（父→子）衰减
        "horizontal": 0.5,             # 水平传播衰减
        "filter": ["combat_*", "explosion_*"],  # 只传播匹配的事件类型（空=全部）
    }
}
```

---

## 三、图拓扑结构

### 3.1 完整示例

```
world_root (type=world)
  │
  ├─ [CONTAINS, up=0.8] → chapter_1 (type=chapter)
  │   │                     state: {status: "active", started_at: "..."}
  │   │                     behaviors: [
  │   │                       {trigger: ON_TICK, conditions: {all events completed},
  │   │                        actions: [{change_state: {status: "completed"}}]}
  │   │                     ]
  │   │
  │   ├─ [CONTAINS] → area_frontier_town (type=area)
  │   │   │             properties: {danger_level: 1, atmosphere: "..."}
  │   │   │             state: {visited: true, visit_count: 5}
  │   │   │
  │   │   ├─ [CONTAINS] → loc_guild_hall (type=location)
  │   │   │   │             properties: {description: "..."}
  │   │   │   │             behaviors: [
  │   │   │   │               {trigger: ON_ENTER, conditions: {first_visit: true},
  │   │   │   │                actions: [{narrative_hint: "描述公会大厅的繁忙场景..."}]}
  │   │   │   │             ]
  │   │   │   │
  │   │   │   ├─ [HOSTS] → npc_guild_girl (type=npc)
  │   │   │   │              properties: {personality: "...", tier: "secondary"}
  │   │   │   │              state: {mood: "cheerful", schedule: "morning"}
  │   │   │   │              behaviors: [
  │   │   │   │                {trigger: ON_TIME, conditions: {hour_gte: 20},
  │   │   │   │                 actions: [{change_state: {schedule: "closed", mood: "tired"}}]},
  │   │   │   │                {trigger: ON_DISPOSITION, disposition_filter: {dimension: "trust", gte: 60},
  │   │   │   │                 actions: [{emit_event: {type: "personal_quest_unlock"}},
  │   │   │   │                           {narrative_hint: "公会柜台小姐看起来想对你说什么私事..."}],
  │   │   │   │                 once: true}
  │   │   │   │              ]
  │   │   │   │
  │   │   │   └─ [HOSTS] → npc_receptionist (type=npc)
  │   │   │
  │   │   ├─ [CONTAINS] → loc_tavern (type=location)
  │   │   │   └─ [HOSTS] → npc_barkeeper (type=npc)
  │   │   │
  │   │   ├─ [HAS_EVENT] → evt_goblin_quest (type=event_def)
  │   │   │                  properties: {narrative_directive: "...", importance: "main"}
  │   │   │                  state: {status: "available"}
  │   │   │                  behaviors: [
  │   │   │                    # 解锁条件（locked → available）
  │   │   │                    {trigger: ON_TICK,
  │   │   │                     conditions: {operator: "and", conditions: []},
  │   │   │                     actions: [{change_state: {status: "available"}}],
  │   │   │                     once: true},
  │   │   │                    # 完成触发（active → completed）
  │   │   │                    {trigger: ON_EVENT, event_filter: "objective_complete",
  │   │   │                     conditions: {game_state: "not_in_combat"},
  │   │   │                     actions: [
  │   │   │                       {change_state: {status: "completed"}},
  │   │   │                       {emit_event: {type: "xp_reward", data: {amount: 100}}},
  │   │   │                       {emit_event: {type: "unlock_event", data: {target: "evt_deeper_mine"}}}
  │   │   │                     ]}
  │   │   │                  ]
  │   │   │
  │   │   └─ [CONNECTS, horizontal=0.5] ←→ area_goblin_cave (type=area)
  │   │                                      properties: {danger_level: 3}
  │   │                                      state: {alert_level: "normal"}
  │   │                                      behaviors: [
  │   │                                        {trigger: ON_EVENT, event_filter: "combat_*",
  │   │                                         actions: [{change_state: {alert_level: "high"}},
  │   │                                                   {spawn: {type: "patrol", parent: "self"}}]}
  │   │                                      ]
  │   │
  │   └─ [GATE] → chapter_2 (type=chapter)
  │                 state: {status: "locked"}
  │                 behaviors: [
  │                   {trigger: ON_EVENT, event_filter: "chapter_complete",
  │                    conditions: {event_triggered: "ch1_final_event"},
  │                    actions: [{change_state: {status: "unlocked"}}]}
  │                 ]
  │
  └─ camp (type=camp)
      │ state: {supplies: 10}
      │
      ├─ [MEMBER_OF] → teammate_priestess (type=npc)
      │                  state: {hp: 20, max_hp: 20, mood: "focused"}
      │                  behaviors: [
      │                    {trigger: ON_EVENT, event_filter: "combat_started",
      │                     actions: [{narrative_hint: "女神官开始默念祈祷词准备治愈术"}]},
      │                    {trigger: ON_DISPOSITION, disposition_filter: {dimension: "approval", lte: -30},
      │                     actions: [{emit_event: {type: "teammate_leave_warning"}},
      │                               {narrative_hint: "女神官看起来对队伍的行事方式越来越不满..."}],
      │                     once: true}
      │                  ]
      │
      └─ [MEMBER_OF] → teammate_high_elf (type=npc)
                         state: {hp: 18, max_hp: 18, mood: "relaxed"}
```

### 3.2 层级关系总结

> **C3 实施变更**: chapter 与 region 同级挂 world_root。
> chapter 是抽象叙事容器，不 CONTAINS 地理节点。
> region 从 area.region 字段自动聚合，是地理容器。

```
Z 轴层级（CONTAINS 边）:
  Level 0: world_root
  Level 1: chapter_1, chapter_2, ..., region_frontier, region_underground, ..., camp
  Level 2: area_frontier_town, area_goblin_cave, ...   （挂在 region 下）
  Level 3: loc_guild_hall, loc_tavern, ...
  Level 4: (叶子节点，通过 HOSTS/HAS_EVENT 边归属)

水平关系（CONNECTS / RELATES_TO / GATE 边）:
  area ←→ area (区域间连接, CONNECTS)
  npc ←→ npc (角色间关系, RELATES_TO)
  chapter → chapter (门控, GATE)

归属关系（HOSTS / HAS_EVENT / MEMBER_OF 边）:
  location/area → npc (HOSTS)
  area → event_def (HAS_EVENT, 锚点为 chapter.available_maps[0])
  npc → camp (MEMBER_OF)
```

---

## 四、WorldGraph 核心类 (`app/world/world_graph.py`)

> **注意**: WorldGraph 容器的完整设计规格、决策记录、API 定义详见子文档：
> **`WorldGraph容器设计.md`**
> 本章保留概要作为快速参考，以子文档为准。
> 子文档相对本章原设计的关键变更：
> - `nx.DiGraph()` → `nx.MultiDiGraph()`（支持 NPC 多维关系）
> - `_parent: Dict[str, str]` → `_parents: Dict[str, Set[str]]`（支持多父引用）
> - `get_node() -> Dict` → `get_node() -> Optional[WorldNode]`（保留类型+方法）
> - 节点 model_dump() 打散存储 → 存 WorldNode 对象引用（复用 C1 方法）
> - 新增 CONNECTS 自动反向边、`query_raw()` 逃生通道、边 key 命名规范

### 4.1 概要

```python
class WorldGraph:
    """三维世界图容器 — 全量内存加载。

    底层: nx.MultiDiGraph()
    索引: _type_index / _children / _parents / _entities_at
    节点存储: WorldNode 对象引用（非 model_dump 打散）
    """

    # 节点 CRUD
    def add_node(self, node: WorldNode) -> None: ...
    def remove_node(self, node_id: str) -> None: ...       # 级联删除后代
    def get_node(self, node_id: str) -> Optional[WorldNode]: ...
    def has_node(self, node_id: str) -> bool: ...

    # 状态修改（自动 dirty 标记）
    def set_state(self, node_id: str, key: str, value: Any) -> None: ...
    def merge_state(self, node_id: str, updates: Dict[str, Any]) -> None: ...

    # Z 轴查询
    def get_children(self, node_id: str, type_filter: str = None) -> List[str]: ...
    def get_parent(self, node_id: str) -> Optional[str]: ...     # 多父时选 active chapter
    def get_all_parents(self, node_id: str) -> Set[str]: ...
    def get_ancestors(self, node_id: str) -> List[str]: ...
    def get_descendants(self, node_id: str, type_filter: str = None) -> List[str]: ...
    def get_scope_chain(self, location_id: str) -> List[str]: ...

    # X/Y 平面查询
    def get_neighbors(self, node_id: str, relation: str = None) -> List[Tuple[str, Dict]]: ...
    def get_connected_areas(self, area_id: str) -> List[str]: ...
    def get_entities_at(self, location_id: str) -> List[str]: ...

    # 类型查询
    def get_by_type(self, node_type: str) -> List[str]: ...
    def find_events_in_scope(self, scope_node_id: str) -> List[str]: ...

    # 原生查询（逃生通道，O(n)，慎用）
    def query_raw(self, predicate: Callable[[WorldNode], bool]) -> List[WorldNode]: ...

    # 边操作
    def add_edge(self, source, target, relation, key=None, **attrs) -> None: ...
    def get_edge(self, source, target, key=None) -> Optional[Dict]: ...
    def get_edges_between(self, source, target) -> List[Dict]: ...
    def update_edge(self, source, target, key, updates: Dict) -> None: ...
    def remove_edge(self, source, target, key=None) -> None: ...

    # 事件日志
    def log_event(self, event: WorldEvent) -> None: ...
    def flush_event_log(self) -> List[WorldEvent]: ...

    # 快照（C2 基础版，C6 扩展）
    def snapshot(self) -> Dict[str, Dict[str, Any]]: ...        # 仅 dirty 节点
    def snapshot_full(self) -> Dict[str, Dict[str, Any]]: ...   # 所有节点
    def restore_snapshot(self, node_states: Dict[str, Dict[str, Any]]) -> None: ...
    def clear_dirty(self) -> None: ...
```

---

## 五、图构建器 (`app/world/graph_builder.py`) ✅ C3 已实施

### 5.1 职责

从现有 `WorldInstance` 数据构建 `WorldGraph`。`WorldInstance` 继续负责 Firestore 加载，`GraphBuilder` 将其注册表数据转换为三维图节点。

**注意**: `build()` 是**同步方法**，纯内存构图。快照恢复由调用方在 `build()` 返回后自行调用 `wg.restore_snapshot()`。

### 5.2 构建流程

```python
class GraphBuilder:
    """从 WorldInstance 构建 WorldGraph。"""

    @staticmethod
    def build(
        world: WorldInstance,
        session: SessionRuntime,
        use_canonical_relationships: bool = True,
    ) -> WorldGraph:
        """
        6 步构建流程（快照恢复由调用方负责）:

        1. world_root — 全局唯一根节点
        2. chapters — 章节节点 + GATE 边 + 解锁 Behavior
           - CONTAINS: world_root → chapter（与 region 同级）
           - chapter 是抽象叙事容器，不 CONTAINS 地理节点
        3. geography — region + area + location
           - region 从 area.region 字段自动聚合
           - CONTAINS: world_root → region → area → location
           - CONNECTS: area ↔ area（自动双向）
        4. events — 事件定义 + HAS_EVENT 边 + Behavior 映射
           - 锚点: chapter.available_maps[0] 对应的 area
           - 无地理锚点事件通过 properties.chapter_id 关联
        5. characters — NPC 节点 + HOSTS 边 + RELATES_TO 边
           - HOSTS: location/area → npc
           - RELATES_TO: 由 use_canonical_relationships 控制
        6. party — camp 节点 + MEMBER_OF 边
        """
```

### 5.3 事件定义映射

StoryEvent 的 `trigger_conditions` / `completion_conditions` / `on_complete` 映射为 `Behavior`：

```python
def _event_to_behaviors(event_data: StoryEvent, event_node_id: str, chapter_id: str) -> List[Behavior]:
    """StoryEvent → Behavior 列表。"""

    # 1. 解锁行为 (ON_TICK, once=True): trigger_conditions → CHANGE_STATE(available)
    #    空 conditions → conditions=None (永真)

    # 2. 完成行为 (ON_TICK, once=True): completion_conditions → CHANGE_STATE(completed)
    #    + on_complete.unlock_events → EMIT_EVENT(event_unlocked)
    #    + on_complete.add_xp → EMIT_EVENT(xp_awarded)
    #    + on_complete.add_items → EMIT_EVENT(item_granted)
    #    completion_conditions 为 None → 不生成 complete behavior（靠 LLM 工具调用推进）
```

### 5.4 已知数据质量问题

> **C3 实施标注**: 以下 3 个问题需后期修补，当前用 TODO 注释标记。

1. **region 节点数据空壳** — region 仅从 `area.region` 字符串自动聚合，只有 name，无 description/properties。后续需在世界数据中补充 region 定义。

2. **空 conditions 事件的永真 behavior** — 某些事件的 `trigger_conditions.conditions` 为空列表，映射为 `conditions=None`（永真 behavior，一创建就触发）。这是源数据质量问题，应在世界数据中补充有效条件。

3. **NPC relationships 数据未区分** — `relationships` 数据混合了世界观背景关系和小说剧情关系。`use_canonical_relationships` 参数控制是否构建，但无法区分两种关系。后续需在源数据中添加分类标记。

---

## 六、行为引擎 (`app/world/behavior_engine.py`)

### 6.1 核心接口

```python
class BehaviorEngine:
    """评估 behaviors，执行 actions，传播事件。"""

    def __init__(self, world: WorldGraph):
        self.world = world
        self._propagator = EventPropagator(world)   # 事件传播器
        self._evaluator = ConditionEvaluator()       # 条件评估器（复用现有逻辑）

    def tick(self, ctx: TickContext) -> TickResult:
        """
        每回合主循环。

        1. 递减活跃节点 behavior 冷却
        2. 确定活跃范围节点
        3. 收集 ON_TICK / ON_TIME / ON_DISPOSITION behaviors
        4. 按 priority 降序排序
        5. 逐个评估 conditions + 执行 actions
        6. EMIT_EVENT → 传播 + 级联
        7. 返回 TickResult（含 events / narrative_hints / pending_flash / state_changes）
        """
        ...

    def handle_event(self, event: WorldEvent, ctx: TickContext) -> TickResult:
        """
        处理单个事件（工具调用后触发）。

        1. 评估 origin 节点自身的 ON_EVENT behaviors
        2. 传播事件 + origin 产生的新事件
        3. 级联处理
        4. 返回 TickResult
        """
        ...

    def handle_enter(self, entity_id: str, location_id: str, ctx: TickContext) -> TickResult:
        """实体进入某位置时调用。触发 ON_ENTER behaviors。"""
        ...

    def handle_exit(self, entity_id: str, location_id: str, ctx: TickContext) -> TickResult:
        """实体离开某位置时调用。触发 ON_EXIT behaviors。"""
        ...
```

### 6.2 TickContext

```python
class TickContext(BaseModel):
    """tick 评估所需的上下文。"""
    session: Any                        # SessionRuntime
    phase: str = "pre"                  # "pre"（A4 阶段）/ "post"（C1 阶段）
    player_location: str = ""           # 当前玩家位置节点 ID
    game_day: int = 1
    game_hour: int = 8
    active_chapter: str = ""
    party_members: List[str] = []       # 活跃队友 ID 列表
    events_triggered: List[str] = []    # 本 session 已触发的事件 ID
    objectives_completed: List[str] = []
    round_count: int = 0                # 本章节回合数
```

### 6.3 活跃范围

不是每次 tick 评估全图所有节点——只评估**与玩家相关的范围**：

```python
def _get_active_nodes(self, ctx: TickContext) -> List[str]:
    """确定本次 tick 需要评估的节点集合。"""
    active = set()

    # 1. 玩家当前位置的作用域链（location → area → chapter → world）
    active.update(self.world.get_scope_chain(ctx.player_location))

    # 2. 当前位置的所有实体（NPC、物品、事件）
    active.update(self.world.get_entities_at(ctx.player_location))

    # 3. 当前区域下的所有 event_def
    area_id = self.world.get_parent(ctx.player_location)
    if area_id:
        active.update(self.world.find_events_in_scope(area_id))

    # 4. 相邻区域（ON_EVENT 传播可能影响到，但 ON_TICK 不评估——由传播处理）
    # 不加入 active，只在传播时涉及

    # 5. camp 和队友节点（始终活跃）
    active.add("camp")
    active.update(ctx.party_members)

    return list(active)
```

### 6.4 传播深度限制

```python
MAX_PROPAGATION_DEPTH = 3       # 事件最多传播 3 层
MAX_CASCADING_ROUNDS = 5        # tick 内最多 5 轮级联
MAX_EVENTS_PER_TICK = 20        # 单次 tick 最多产生 20 个事件
```

---

## 七、事件传播 (`app/world/event_propagation.py`)

### 7.1 传播算法

```python
class EventPropagator:
    """事件沿图边传播 — 本质是带衰减的 BFS。"""

    def __init__(self, world: WorldGraph):
        self.world = world

    def propagate(self, event: WorldEvent, ctx: TickContext) -> List[BehaviorResult]:
        """
        从 event.origin_node 出发，BFS 传播事件。

        传播规则:
        1. 向上（子→父）: strength *= edge.propagation.up (默认 0.8)
        2. 向下（父→子）: strength *= edge.propagation.down (默认 0.6)
        3. 水平（CONNECTS）: strength *= edge.propagation.horizontal (默认 0.5)
        4. strength < event.min_strength 时停止
        5. 每到达一个节点，评估该节点的 ON_EVENT behaviors
        6. visibility 控制传播范围:
           - "local": 不传播，仅 origin 节点
           - "scope": 沿作用域链传播（向上到 world，向下到子节点）
           - "global": 全图传播（包括所有水平连接）
        """
        results = []
        visited = {event.origin_node}
        queue = deque()  # (node_id, current_strength)

        # 起始：origin 节点的邻居
        for neighbor, direction in self._get_propagation_targets(event.origin_node, event.visibility):
            decay = self._get_decay(event.origin_node, neighbor, direction)
            new_strength = event.strength * decay
            if new_strength >= event.min_strength:
                queue.append((neighbor, new_strength, 0))  # (node, strength, depth)

        while queue:
            node_id, strength, depth = queue.popleft()
            if node_id in visited or depth >= MAX_PROPAGATION_DEPTH:
                continue
            visited.add(node_id)

            # 评估该节点的 ON_EVENT behaviors
            weakened_event = event.model_copy(update={"strength": strength})
            node_results = self._evaluate_node_behaviors(node_id, weakened_event, ctx)
            results.extend(node_results)

            # 继续传播
            for next_node, direction in self._get_propagation_targets(node_id, event.visibility):
                if next_node not in visited:
                    decay = self._get_decay(node_id, next_node, direction)
                    next_strength = strength * decay
                    if next_strength >= event.min_strength:
                        queue.append((next_node, next_strength, depth + 1))

        return results
```

### 7.2 传播方向

```python
def _get_propagation_targets(self, node_id: str, visibility: str) -> List[Tuple[str, str]]:
    """获取传播目标和方向。"""
    targets = []

    # 向上传播（所有 visibility 都可以）
    parent = self.world.get_parent(node_id)
    if parent:
        targets.append((parent, "up"))

    # 向下传播
    for child in self.world.get_children(node_id):
        targets.append((child, "down"))

    # 水平传播（仅 "global" 或者 "scope" 中同层级）
    if visibility in ("global", "scope"):
        for neighbor in self.world.get_neighbors(node_id, relation="connects"):
            targets.append((neighbor, "horizontal"))

    return targets
```

### 7.3 衰减系数（默认值）

| 方向 | 默认衰减 | 含义 |
|------|---------|------|
| 向上 (up) | 0.8 | 子地点发生的事，上级区域大概率知道 |
| 向下 (down) | 0.6 | 区域发生的事，子地点不一定都知道 |
| 水平 (horizontal) | 0.5 | 相邻区域的事，弱传播 |

边可以自定义覆盖默认值（如特殊通道传声更好）。

---

## 八、管线集成

### 8.1 替代关系

| 现有组件 | 替代方案 | 说明 |
|---------|---------|------|
| `WorldInstance` 数据加载 | **保留** | 继续负责 Firestore → 内存的数据加载 |
| `WorldInstance` 注册表查询 | **WorldGraph 查询替代** | `get_characters_in_area()` → `world.get_entities_at()` |
| `AreaRuntime.check_events()` | **BehaviorEngine.tick()** | 通用行为引擎替代硬编码状态机 |
| `AreaRuntime.check_chapter_transition()` | **chapter 节点的 Behavior** | 章节门控变成图上的 GATE 边 + behavior |
| `AreaRuntime._apply_on_complete()` | **Behavior.actions** | 副作用变成 Action 列表 |
| `AreaRuntime._eval_*()` 条件评估 | **ConditionEvaluator 复用** | 8+1 条件类型完全复用 |
| `EventBus` + `AdminEventService` | **WorldGraph.propagate()** | 事件沿图传播替代 pub/sub |
| `CompanionInstance` 事件分发 | **camp/teammate 节点的 ON_EVENT behaviors** | 队友节点自动接收传播事件 |

### 8.2 管线阶段调整

```
当前管线:
  A1-A3: WorldInstance + SessionRuntime + ContextAssembler
  A4:    AreaRuntime.check_events(pre)           ← 替换
  B:     FlashCPU agentic                        ← 工具操作 WorldGraph
  C1:    AreaRuntime.check_events(post)          ← 替换
  C2:    CompanionInstance dispatch               ← 替换
  C3:    TeammateResponseService                 ← Phase A (Agent化) 替换
  C4:    SessionRuntime.persist()                ← 改为快照

新管线:
  A1-A3: WorldInstance + SessionRuntime + WorldGraph 提供上下文
  A4:    BehaviorEngine.tick(phase="pre")
  B:     FlashCPU agentic → 工具修改 WorldGraph.state → propagate()
  C1:    BehaviorEngine.tick(phase="post")
  C2:    事件已通过传播到达 teammate 节点（不需要单独分发）
  C3:    TeammateAgenticService（从 WorldGraph 获取事件）
  C4:    仅内存更新（Firestore 写入推迟到退出）
```

### 8.3 V4AgenticToolRegistry 改动

工具调用不再直接操作 AreaRuntime，改为操作 WorldGraph：

```python
# 示例: navigate 工具
async def navigate(self, target_area_id: str) -> Dict:
    # 修改玩家节点 state
    self.world_graph.set_state("player", "current_location", target_area_id)

    # 触发 ON_EXIT (旧位置) + ON_ENTER (新位置)
    old_loc = ...
    events = self.world_graph.engine.handle_exit("player", old_loc)
    events += self.world_graph.engine.handle_enter("player", target_area_id)

    # 生成导航事件并传播
    nav_event = WorldEvent(event_type="location_entered", origin_node=target_area_id, ...)
    events += self.world_graph.engine.handle_event(nav_event)

    return {"success": True, "events": events}

# 示例: activate_event 工具
async def activate_event(self, event_id: str) -> Dict:
    # 直接修改 event_def 节点的 state
    self.world_graph.set_state(event_id, "status", "active")

    # state 变化传播
    event = WorldEvent(event_type="event_activated", origin_node=event_id, ...)
    self.world_graph.engine.handle_event(event)

    return {"success": True}
```

---

## 九、快照持久化 (`app/world/snapshot.py`) ✅ C6 已实施

> **实际实现与原设计的偏差**:
> - 删掉 `behavior_states` — 行为状态（`behavior_fired` / `behavior_cooldowns`）已嵌入 `node.state`，通过 `node_states` 自动持久化
> - `snapshot.py` 纯序列化，不含 Firestore I/O（由调用方负责读写）
> - 追踪机制采用追踪集合方式（非 diff 对比），`WorldGraph.seal()` 控制构建期/运行期切换
> - `modified_edges` 使用 `EdgeChangeRecord` 模型，支持 add/update/remove 操作压缩

### 9.1 快照内容

```python
class WorldSnapshot(BaseModel):
    """世界状态快照 — 只存可变部分。"""
    world_id: str
    session_id: str
    created_at: datetime
    game_day: int
    game_hour: int

    # 脏节点的 state 快照 {node_id: state_dict}
    # 注: behavior_fired / behavior_cooldowns 自动包含在 state 中
    node_states: Dict[str, Dict[str, Any]]

    # 运行期动态创建的节点（完整 model_dump）
    spawned_nodes: List[Dict[str, Any]]

    # 运行期动态移除的节点 ID
    removed_node_ids: List[str]

    # 压缩后的边变更记录
    modified_edges: List[EdgeChangeRecord]
```

### 9.2 Firestore 路径

```
worlds/{world_id}/sessions/{session_id}/world_snapshot
```

单文档存储（世界不大，快照 JSON 预估 < 100KB）。

### 9.3 生命周期

```
新建会话:
  GraphBuilder.build() → wg.seal() → WorldGraph（干净状态）

游戏过程:
  BehaviorEngine.tick() / handle_event() → 状态变更、SPAWN、REMOVE、边变更
  ↓ 追踪记录在 WorldGraph 内部集合中

保存:
  capture_snapshot(wg, ...) → WorldSnapshot → snapshot_to_dict() → Dict
  → 调用方写入 Firestore: worlds/{wid}/sessions/{sid}/world_snapshot

恢复会话:
  GraphBuilder.build() → wg.seal()
  → dict_to_snapshot(firestore_data) → WorldSnapshot
  → restore_snapshot(wg, snapshot) → 重现运行时状态
```

### 9.4 恢复顺序

```
Phase 1: 临时解除 seal（避免恢复操作被追踪）
Phase 2: 重建 spawned 节点（后续 edge/state 恢复需要节点存在）
Phase 3: 删除 removed 节点
Phase 4: 重放 edge 变更（节点必须已存在，add 时 one_way=True 避免重复反向边）
Phase 5: 恢复 node states（最后执行，覆盖前面步骤可能产生的副作用）
Phase 6: 重新 seal + clear_dirty
```

---

## 十、与现有系统的兼容

### 10.1 保留的系统

| 系统 | 状态 | 原因 |
|------|------|------|
| `WorldInstance` | 保留 | 继续负责 Firestore 静态数据加载 |
| `MemoryGraph` | 保留 | 个人记忆图谱（主观视角），与 WorldGraph（客观世界）是不同的图 |
| `GraphStore` | 保留 | MemoryGraph 的持久化层不变 |
| `SpreadingActivation` | 保留 | 记忆检索算法不变 |
| `ConditionGroup/Condition` | 完全复用 | BehaviorEngine 的条件评估直接使用现有系统 |

### 10.2 渐进替代的系统

| 系统 | 替代时机 | 说明 |
|------|---------|------|
| `AreaRuntime.check_events()` | Phase C 完成后 | 事件状态机 → BehaviorEngine.tick() |
| `AreaRuntime.check_chapter_transition()` | Phase C 完成后 | → chapter 节点 GATE behavior |
| `AreaRuntime._apply_on_complete()` | Phase C 完成后 | → Behavior.actions |
| `AreaRuntime` 条件评估器 | 复用代码，删除重复 | 提取到独立 ConditionEvaluator |
| `EventBus` | Phase C 完成后 | → WorldGraph.propagate() |
| `AdminEventService` 结构化入图 | 保留但简化 | 入图逻辑保留，触发逻辑删除 |

### 10.3 数据兼容

- **现有 chapters_v2.json / maps.json**: `GraphBuilder` 的 `_event_to_behaviors()` 直接映射，不需要修改数据文件
- **现有 Firestore 数据**: `WorldInstance` 的加载逻辑不变
- **现有 session 数据**: 新增 `world_snapshot` 文档，不影响现有 session 结构

---

## 十一、实施步骤

```
Step C1: 数据模型（models.py）                          ✅ 已完成
  └─ WorldNode / Behavior / Action / WorldEvent / TriggerType / ActionType
  └─ 详见子文档: 世界图数据模型设计（已实施）.md

Step C2: WorldGraph 核心（world_graph.py）                ✅ 已完成
  └─ 图结构 + 索引 + CRUD + 查询
  └─ 详见子文档: WorldGraph容器设计.md
  └─ 依赖 C1

Step C3: GraphBuilder（graph_builder.py）                 ✅ 已完成
  └─ 同步 build()，6 步构建（快照恢复由调用方负责）
  └─ chapter/region 同级结构，region 自动聚合
  └─ 事件定义 → Behavior 映射（含空条件永真处理）
  └─ NPC RELATES_TO 双模式（use_canonical_relationships）
  └─ 39 个单元测试通过
  └─ 依赖 C1 + C2

Step C4: BehaviorEngine（behavior_engine.py）                ✅ 已完成
  └─ ConditionEvaluator: 9 条件处理器从 AreaRuntime 提取，改用 TickContext
  └─ ActionExecutor: 6 种 ActionType 执行（CHANGE_STATE 立即生效）
  └─ BehaviorEngine: tick() + handle_event() + handle_enter/exit()
  └─ 级联限制: MAX_CASCADING_ROUNDS=5, MAX_EVENTS_PER_TICK=20
  └─ TickContext 扩展: +player_sub_location, +npc_interactions, +game_state
  └─ 新增 EvalResult / TickResult 模型
  └─ 依赖 C1 + C2 + C5

Step C5: EventPropagator（event_propagation.py）             ✅ 已完成
  └─ BFS 传播 + 衰减（up:0.8, down:0.6, horizontal:0.5）
  └─ 只返回到达节点列表，不评估 behaviors（由 BehaviorEngine 负责）
  └─ MAX_DEPTH=3, visited 防重访, 边可自定义 propagation 衰减
  └─ 依赖 C1 + C2

Step C6: 快照持久化（snapshot.py）                       ✅ 已完成
  └─ WorldGraph 追踪基础设施: _sealed / _spawned_nodes / _removed_node_ids / _edge_changes
  └─ seal() 机制: GraphBuilder.build() 末尾调用，控制构建期/运行期切换
  └─ capture_snapshot(): dirty states + spawned nodes + removed ids + 边变更压缩
  └─ restore_snapshot(): 5 阶段恢复（unseal → spawn → remove → edge → state → reseal）
  └─ 序列化: snapshot_to_dict() / dict_to_snapshot()（datetime ↔ ISO string）
  └─ 删掉 behavior_states（已嵌入 node.state）
  └─ 29 个单元测试通过
  └─ 依赖 C2

Step C7: 管线集成
  └─ pipeline_orchestrator.py: A4/C1 阶段替换
  └─ SessionRuntime: 挂载 WorldGraph
  └─ V4AgenticToolRegistry: 工具操作 WorldGraph
  └─ 依赖 C1-C6 全部
```

---

## 十二、风险与缓解

| 风险 | 影响 | 缓解 |
|------|------|------|
| 全量加载内存占用 | 中 | 当前世界数据 < 10MB，完全可承受 |
| tick 评估性能 | 低 | 活跃范围限制（只评估玩家作用域），非全图遍历 |
| 事件传播无限循环 | 高 | MAX_PROPAGATION_DEPTH=3 + MAX_EVENTS_PER_TICK=20 + visited 集合 |
| 快照数据一致性 | 中 | 退出时统一快照；异常退出可能丢失数据 → 可加定期自动快照 |
| 行为冲突（两个 behavior 同时修改同一 state） | 中 | priority 排序 + 后执行的覆盖前执行的（确定性） |
| 与 AreaRuntime 并行期的状态不一致 | 中 | 渐进替代：先双写（WorldGraph + AreaRuntime），验证一致后删 AreaRuntime |
| ConditionEvaluator 从 AreaRuntime 提取的工作量 | 低 | 条件评估器逻辑独立，抽取为纯函数 |
