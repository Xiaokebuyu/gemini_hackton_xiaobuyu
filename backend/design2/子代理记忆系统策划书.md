# 🧠 子代理核心热记忆系统 - 架构策划书

> **版本**: v1.0  
> **日期**: 2026-01-17  
> **状态**: 设计阶段

---

## 📋 目录

1. [项目愿景](#1-项目愿景)
2. [系统架构](#2-系统架构)
3. [核心组件](#3-核心组件)
4. [数据模型](#4-数据模型)
5. [工作流设计](#5-工作流设计)
6. [MCP 接口设计](#6-mcp-接口设计)
7. [技术栈](#7-技术栈)
8. [实现路线图](#8-实现路线图)
9. [与现有代码的关系](#9-与现有代码的关系)

---

## 1. 项目愿景

### 1.1 核心目标

构建一个**以子代理为核心**的 LLM 长期记忆系统，实现：

- **模块化架构**：每个功能封装为独立子代理，可按需组合
- **热冷分离**：活跃对话（热记忆）与归档知识（冷记忆）分层管理
- **智能召回**：根据对话上下文自动检索相关记忆
- **标准化接口**：通过 MCP 协议暴露能力，支持多客户端接入

### 1.2 设计原则

| 原则 | 说明 |
|------|------|
| **子代理优先** | 功能拆分为专职子代理，主代理负责协调 |
| **共享上下文** | 减少重复数据加载，子代理间共享状态 |
| **渐进式增强** | 核心功能先行，高级功能后续添加 |
| **协议标准化** | 使用 MCP 作为对外接口，便于生态集成 |

### 1.3 目标用户场景

```
┌─────────────────────────────────────────────────────────────┐
│  场景 1: Claude Desktop / Cursor 用户                        │
│  → 通过 MCP 直接使用记忆系统                                  │
├─────────────────────────────────────────────────────────────┤
│  场景 2: Web 应用用户                                        │
│  → 通过前端界面与记忆系统交互                                  │
├─────────────────────────────────────────────────────────────┤
│  场景 3: 开发者                                              │
│  → 将记忆系统集成到自己的 AI 应用中                            │
└─────────────────────────────────────────────────────────────┘
```

---

## 2. 系统架构

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                        外部客户端层                              │
├─────────────────────────────────────────────────────────────────┤
│   Claude Desktop    │    Cursor AI    │    自定义应用/前端       │
└──────────┬──────────┴────────┬────────┴──────────┬──────────────┘
           │                   │                   │
           └───────────────────┼───────────────────┘
                               ↓
┌─────────────────────────────────────────────────────────────────┐
│                      MCP Server 层                              │
│                   (标准化对外接口)                               │
├─────────────────────────────────────────────────────────────────┤
│  Tools:                    │  Resources:                        │
│  • chat                    │  • memory://topics                 │
│  • search_memory           │  • memory://messages               │
│  • get_context             │  • memory://stats                  │
│  • archive                 │                                    │
└─────────────────────────────────────────────────────────────────┘
                               ↓
┌─────────────────────────────────────────────────────────────────┐
│                      子代理层 (核心)                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              🎯 主代理 (Orchestrator)                    │   │
│  │           接收请求 → 分析意图 → 调度子代理 → 整合响应      │   │
│  └────────────────────────────┬────────────────────────────┘   │
│                               │                                 │
│       ┌───────────────────────┼───────────────────────┐        │
│       ↓                       ↓                       ↓        │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐      │
│  │ 🔍🧩 记忆代理 │    │  📝 归档代理  │    │  ✨ 总结代理  │      │
│  │ MemoryAgent  │    │  Archiver    │    │  Summarizer │      │
│  ├──────────────┤    ├──────────────┤    ├──────────────┤      │
│  │ 共享上下文:   │    │ • 检测时机   │    │ • 对话压缩   │      │
│  │ • 检索模式   │    │ • 主题识别   │    │ • Artifact  │      │
│  │ • 构建模式   │    │ • 生成文档   │    │   更新      │      │
│  └──────────────┘    └──────────────┘    └──────────────┘      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
                               ↓
┌─────────────────────────────────────────────────────────────────┐
│                      记忆存储层                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────┐    ┌─────────────────────┐            │
│  │   🔥 热记忆 (Hot)    │    │   ❄️ 冷记忆 (Cold)   │            │
│  ├─────────────────────┤    ├─────────────────────┤            │
│  │ • 最近 N 条消息     │    │ • 归档的 Topics     │            │
│  │ • 活跃对话窗口      │    │ • Artifact 文档     │            │
│  │ • 快速访问          │    │ • 结构化知识        │            │
│  └─────────────────────┘    └─────────────────────┘            │
│                    ↓                    ↓                       │
│              ┌─────────────────────────────────┐               │
│              │          Firestore              │               │
│              │   (持久化存储 + 实时同步)         │               │
│              └─────────────────────────────────┘               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 层次职责

| 层次 | 职责 | 关键组件 |
|------|------|----------|
| **客户端层** | 用户交互入口 | Claude Desktop, Cursor, Web 前端 |
| **MCP 层** | 标准化接口，协议转换 | MCP Server, Tools, Resources |
| **子代理层** | 核心业务逻辑 | Orchestrator, MemoryAgent, Archiver, Summarizer |
| **存储层** | 数据持久化 | Firestore, 热/冷记忆分区 |

---

## 3. 核心组件

### 3.1 主代理 (Orchestrator)

**职责**：接收用户请求，分析意图，调度合适的子代理，整合最终响应。

```python
class Orchestrator:
    """主代理 - 子代理系统的协调中心"""
    
    def __init__(self):
        self.memory_agent = MemoryAgent()
        self.archiver = ArchiverAgent()
        self.summarizer = SummarizerAgent()
        self.llm = GeminiClient()
    
    async def process(self, user_message: str, context: SessionContext) -> Response:
        """处理用户请求的主流程"""
        
        # 1. 初始化共享上下文
        await self.memory_agent.init_context(context.user_id, context.session_id)
        
        # 2. 分析意图，决定调用哪些子代理
        intent = await self._analyze_intent(user_message)
        
        # 3. 根据意图调度子代理
        if intent.needs_memory_search:
            await self.memory_agent.search(intent.search_keywords)
        
        # 4. 构建 LLM 上下文
        llm_context = await self.memory_agent.build_context()
        
        # 5. 生成响应
        response = await self.llm.generate(user_message, llm_context)
        
        # 6. 后处理：检查是否需要归档
        if await self.archiver.should_archive(context):
            await self.archiver.archive(context)
        
        return response
```

**关键能力**：
- 意图分析（是否需要检索、是否需要归档等）
- 子代理调度（决定调用顺序和组合）
- 响应整合（汇总子代理结果）

---

### 3.2 记忆代理 (MemoryAgent)

**职责**：统一管理记忆检索和上下文构建，共享加载的数据。

```python
class SharedContext:
    """检索和上下文构建共享的状态"""
    
    def __init__(self, user_id: str, session_id: str):
        self.user_id = user_id
        self.session_id = session_id
        
        # 缓存数据
        self.hot_messages: List[Message] = []      # 热记忆
        self.topics_index: Dict[str, Topic] = {}   # 主题索引
        self.search_results: List[SearchHit] = []  # 检索结果
        
        # 状态标记
        self.is_loaded = False

class MemoryAgent:
    """记忆代理 - 统一的检索 + 上下文构建"""
    
    def __init__(self, firestore: FirestoreService):
        self.firestore = firestore
        self.context: SharedContext = None
    
    async def init_context(self, user_id: str, session_id: str):
        """初始化共享上下文（数据只加载一次）"""
        self.context = SharedContext(user_id, session_id)
        
        # 并行加载热记忆和主题索引
        self.context.hot_messages, topics = await asyncio.gather(
            self.firestore.get_recent_messages(user_id, session_id, limit=100),
            self.firestore.get_all_topics(user_id, session_id)
        )
        self.context.topics_index = {t.thread_id: t for t in topics}
        self.context.is_loaded = True
    
    async def search(self, keywords: List[str]) -> List[SearchHit]:
        """检索模式：搜索相关记忆"""
        results = []
        
        # 搜索热记忆
        for msg in self.context.hot_messages:
            if self._match_keywords(keywords, msg.content):
                results.append(SearchHit(source="hot", data=msg, score=...))
        
        # 搜索冷记忆
        for topic in self.context.topics_index.values():
            if self._match_keywords(keywords, topic.current_artifact):
                results.append(SearchHit(source="cold", data=topic, score=...))
        
        # 按相关度排序
        results.sort(key=lambda x: x.score, reverse=True)
        self.context.search_results = results
        return results
    
    async def build_context(self, max_tokens: int = 4000) -> str:
        """构建模式：组装 LLM 上下文"""
        parts = []
        
        # 1. 系统提示
        parts.append(self._get_system_prompt())
        
        # 2. 相关知识（冷记忆检索结果）
        if self.context.search_results:
            parts.append("## 相关知识")
            for hit in self.context.search_results[:3]:  # Top 3
                if hit.source == "cold":
                    parts.append(f"### {hit.data.title}\n{hit.data.current_artifact}")
        
        # 3. 最近对话（热记忆）
        parts.append("## 最近对话")
        for msg in self.context.hot_messages[-20:]:
            parts.append(f"{msg.role}: {msg.content}")
        
        return "\n\n".join(parts)
```

**关键能力**：
- 共享上下文（避免重复加载）
- 双模式操作（检索 + 构建）
- 智能排序（相关度优先）

---

### 3.3 归档代理 (ArchiverAgent)

**职责**：检测归档时机，识别主题，生成结构化知识文档。

```python
class ArchiverAgent:
    """归档代理 - 将对话转化为持久知识"""
    
    def __init__(self, firestore: FirestoreService, llm: GeminiClient):
        self.firestore = firestore
        self.llm = llm
    
    async def should_archive(self, context: SessionContext) -> bool:
        """检测是否需要归档"""
        unarchived_count = await self.firestore.count_unarchived_messages(
            context.user_id, context.session_id
        )
        return unarchived_count >= context.config.archive_threshold  # 默认 20 条
    
    async def archive(self, context: SessionContext) -> ArchiveResult:
        """执行归档流程"""
        
        # 1. 获取待归档消息
        messages = await self.firestore.get_unarchived_messages(
            context.user_id, context.session_id
        )
        
        # 2. 分析主题
        analysis = await self.llm.analyze_for_archive(messages)
        
        # 3. 生成或更新 Artifact
        if analysis.is_new_topic:
            artifact = await self._create_artifact(analysis, messages)
            await self.firestore.create_topic(context.user_id, context.session_id, artifact)
        else:
            existing = await self.firestore.get_topic(analysis.matched_topic_id)
            updated = await self._merge_artifact(existing, analysis, messages)
            await self.firestore.update_topic(analysis.matched_topic_id, updated)
        
        # 4. 标记消息为已归档
        await self.firestore.mark_messages_archived(
            [m.id for m in messages],
            analysis.topic_id
        )
        
        return ArchiveResult(topic_id=analysis.topic_id, message_count=len(messages))
```

**关键能力**：
- 时机检测（基于消息数量阈值）
- 主题识别（新主题 vs 已有主题）
- Artifact 生成与更新

---

### 3.4 总结代理 (SummarizerAgent)

**职责**：压缩长对话，更新知识文档，进行知识蒸馏。

```python
class SummarizerAgent:
    """总结代理 - 信息压缩与知识蒸馏"""
    
    def __init__(self, llm: GeminiClient):
        self.llm = llm
    
    async def summarize_conversation(self, messages: List[Message]) -> str:
        """总结对话，提取关键信息"""
        prompt = f"""
        请总结以下对话的关键内容，提取：
        1. 讨论的主要话题
        2. 达成的结论或决定
        3. 重要的事实信息
        4. 待办事项（如有）
        
        对话内容：
        {self._format_messages(messages)}
        """
        return await self.llm.generate(prompt)
    
    async def update_artifact(self, artifact: str, new_content: str) -> str:
        """智能更新 Artifact，融合新知识"""
        prompt = f"""
        请将新内容融合到现有知识文档中：
        - 保留现有文档的结构
        - 添加新的信息
        - 更新过时的内容
        - 避免重复
        
        现有文档：
        {artifact}
        
        新内容：
        {new_content}
        """
        return await self.llm.generate(prompt)
    
    async def compress_context(self, context: str, target_tokens: int) -> str:
        """压缩上下文以适应 token 限制"""
        # 智能压缩，保留关键信息
        ...
```

**关键能力**：
- 对话总结（提取关键信息）
- Artifact 更新（知识融合）
- 上下文压缩（token 优化）

---

## 4. 数据模型

### 4.1 核心实体

```python
from dataclasses import dataclass
from typing import Optional, List
from datetime import datetime
from enum import Enum

class MessageStatus(Enum):
    ACTIVE = "active"           # 活跃（未归档）
    ARCHIVED = "archived"       # 已归档
    EXCLUDED = "excluded"       # 已排除（不参与归档）

@dataclass
class Message:
    """消息实体"""
    id: str
    user_id: str
    session_id: str
    role: str                   # "user" | "assistant" | "system"
    content: str
    status: MessageStatus
    thread_id: Optional[str]    # 归档后关联的主题 ID
    created_at: datetime
    metadata: dict              # 扩展字段

@dataclass
class Topic:
    """主题实体"""
    thread_id: str
    user_id: str
    session_id: str
    title: str
    summary: str
    current_artifact: str       # Markdown 格式的知识文档
    source_message_ids: List[str]
    created_at: datetime
    updated_at: datetime
    metadata: dict

@dataclass
class Session:
    """会话实体"""
    session_id: str
    user_id: str
    title: str
    config: SessionConfig
    created_at: datetime
    last_active_at: datetime

@dataclass
class SessionConfig:
    """会话配置"""
    archive_threshold: int = 20     # 归档触发阈值
    hot_memory_limit: int = 100     # 热记忆窗口大小
    thinking_level: str = "medium"  # Gemini 思考级别
```

### 4.2 Firestore 集合结构

```
firestore/
├── users/
│   └── {user_id}/
│       ├── sessions/
│       │   └── {session_id}/
│       │       ├── config: SessionConfig
│       │       ├── messages/
│       │       │   └── {message_id}: Message
│       │       └── topics/
│       │           └── {thread_id}: Topic
│       └── global_settings/
│           └── preferences: UserPreferences
```

---

## 5. 工作流设计

### 5.1 对话处理流程

```
┌─────────────────────────────────────────────────────────────────┐
│                     用户发送消息                                 │
└───────────────────────────┬─────────────────────────────────────┘
                            ↓
┌───────────────────────────────────────────────────────────────┐
│  1. MCP Server 接收请求                                        │
│     - 验证参数                                                 │
│     - 创建 SessionContext                                      │
└───────────────────────────┬───────────────────────────────────┘
                            ↓
┌───────────────────────────────────────────────────────────────┐
│  2. Orchestrator.process()                                     │
│     - 保存用户消息到 Firestore                                  │
│     - 初始化 MemoryAgent 共享上下文                             │
└───────────────────────────┬───────────────────────────────────┘
                            ↓
┌───────────────────────────────────────────────────────────────┐
│  3. 意图分析                                                   │
│     - 是否需要检索记忆？                                        │
│     - 提取搜索关键词                                           │
└───────────────────────────┬───────────────────────────────────┘
                            ↓
            ┌───────────────┴───────────────┐
            ↓ 需要检索                       ↓ 不需要
┌───────────────────────┐       ┌───────────────────────┐
│  4a. MemoryAgent      │       │  4b. 直接构建上下文    │
│      .search()        │       │                       │
└───────────┬───────────┘       └───────────┬───────────┘
            └───────────────┬───────────────┘
                            ↓
┌───────────────────────────────────────────────────────────────┐
│  5. MemoryAgent.build_context()                                │
│     - 组装热记忆 + 冷记忆检索结果                                │
│     - 生成 LLM 上下文                                          │
└───────────────────────────┬───────────────────────────────────┘
                            ↓
┌───────────────────────────────────────────────────────────────┐
│  6. 调用 Gemini API 生成响应                                   │
│     - 传入构建好的上下文                                        │
│     - 获取 AI 回复                                             │
└───────────────────────────┬───────────────────────────────────┘
                            ↓
┌───────────────────────────────────────────────────────────────┐
│  7. 保存 AI 回复到 Firestore                                   │
└───────────────────────────┬───────────────────────────────────┘
                            ↓
┌───────────────────────────────────────────────────────────────┐
│  8. 后处理检查                                                 │
│     - ArchiverAgent.should_archive()?                         │
│     - 如需归档则执行 archive()                                  │
└───────────────────────────┬───────────────────────────────────┘
                            ↓
┌───────────────────────────────────────────────────────────────┐
│  9. 返回响应给客户端                                           │
└─────────────────────────────────────────────────────────────────┘
```

### 5.2 归档流程

```
┌─────────────────────────────────────────────────────────────────┐
│              ArchiverAgent.should_archive() = True              │
└───────────────────────────┬─────────────────────────────────────┘
                            ↓
┌───────────────────────────────────────────────────────────────┐
│  1. 获取待归档消息                                              │
│     - 查询 status = ACTIVE 的消息                              │
│     - 按时间排序                                               │
└───────────────────────────┬───────────────────────────────────┘
                            ↓
┌───────────────────────────────────────────────────────────────┐
│  2. LLM 分析主题                                               │
│     - 识别对话主题                                             │
│     - 判断是否匹配已有 Topic                                    │
│     - 提取关键知识点                                           │
└───────────────────────────┬───────────────────────────────────┘
                            ↓
            ┌───────────────┴───────────────┐
            ↓ 新主题                         ↓ 已有主题
┌───────────────────────┐       ┌───────────────────────┐
│  3a. 创建新 Topic      │       │  3b. 更新已有 Topic    │
│  - 生成 Artifact      │       │  - 融合新内容到       │
│  - 设置 title/summary │       │    现有 Artifact      │
└───────────┬───────────┘       └───────────┬───────────┘
            └───────────────┬───────────────┘
                            ↓
┌───────────────────────────────────────────────────────────────┐
│  4. 更新消息状态                                               │
│     - status = ARCHIVED                                        │
│     - thread_id = 关联的主题 ID                                 │
└───────────────────────────────────────────────────────────────┘
```

---

## 6. MCP 接口设计

### 6.1 Tools 定义

```python
# MCP Tools 列表

TOOLS = [
    {
        "name": "chat",
        "description": "与 AI 助手对话，自动管理记忆上下文",
        "parameters": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string",
                    "description": "用户消息"
                },
                "session_id": {
                    "type": "string",
                    "description": "会话 ID，可选，默认使用当前活跃会话"
                }
            },
            "required": ["message"]
        }
    },
    {
        "name": "search_memory",
        "description": "搜索用户的长期记忆和知识库",
        "parameters": {
            "type": "object",
            "properties": {
                "keywords": {
                    "type": "array",
                    "items": {"type": "string"},
                    "description": "搜索关键词列表"
                },
                "time_range": {
                    "type": "string",
                    "enum": ["recent", "all"],
                    "description": "搜索范围"
                }
            },
            "required": ["keywords"]
        }
    },
    {
        "name": "list_topics",
        "description": "列出所有已归档的知识主题",
        "parameters": {
            "type": "object",
            "properties": {
                "session_id": {
                    "type": "string",
                    "description": "会话 ID，可选"
                }
            }
        }
    },
    {
        "name": "get_artifact",
        "description": "获取特定主题的知识文档",
        "parameters": {
            "type": "object",
            "properties": {
                "topic_id": {
                    "type": "string",
                    "description": "主题 ID"
                }
            },
            "required": ["topic_id"]
        }
    },
    {
        "name": "create_session",
        "description": "创建新的对话会话",
        "parameters": {
            "type": "object",
            "properties": {
                "title": {
                    "type": "string",
                    "description": "会话标题"
                }
            }
        }
    },
    {
        "name": "list_sessions",
        "description": "列出用户的所有会话",
        "parameters": {
            "type": "object",
            "properties": {}
        }
    }
]
```

### 6.2 Resources 定义

```python
# MCP Resources 列表

RESOURCES = [
    {
        "uri": "memory://topics",
        "name": "All Topics",
        "description": "所有归档主题的列表"
    },
    {
        "uri": "memory://topics/{topic_id}",
        "name": "Topic Detail",
        "description": "特定主题的详细内容"
    },
    {
        "uri": "memory://messages/recent",
        "name": "Recent Messages",
        "description": "最近的对话消息"
    },
    {
        "uri": "memory://sessions",
        "name": "Sessions List",
        "description": "所有会话列表"
    },
    {
        "uri": "memory://stats",
        "name": "Memory Statistics",
        "description": "记忆系统使用统计"
    }
]
```

---

## 7. 技术栈

### 7.1 核心技术

| 组件 | 技术选型 | 说明 |
|------|----------|------|
| **LLM** | Gemini 3 Flash | 支持思考模式、函数调用 |
| **MCP Server** | Python `mcp` SDK | 官方 MCP Python 实现 |
| **数据库** | Firestore | 实时同步、免运维 |
| **异步框架** | asyncio | Python 原生异步 |
| **验证** | Pydantic | 数据模型验证 |

### 7.2 依赖清单

```txt
# requirements.txt

# MCP
mcp>=0.9.0

# Google
google-genai>=1.59.0
google-cloud-firestore>=2.0.0

# 异步
aiohttp>=3.9.0

# 工具
pydantic>=2.0.0
python-dotenv>=1.0.0
```

---

## 8. 实现路线图

### Phase 1: 核心框架（Week 1-2）

```
□ 1.1 项目结构搭建
  ├── 创建 agents/ 目录结构
  ├── 创建 memory/ 目录结构
  └── 配置开发环境

□ 1.2 MemoryAgent 实现
  ├── SharedContext 类
  ├── init_context() 方法
  ├── search() 方法
  └── build_context() 方法

□ 1.3 Orchestrator 基础版
  ├── 简单的意图分析
  ├── MemoryAgent 集成
  └── LLM 调用封装
```

### Phase 2: 归档系统（Week 3-4）

```
□ 2.1 ArchiverAgent 实现
  ├── should_archive() 检测
  ├── 主题识别逻辑
  └── Artifact 生成

□ 2.2 SummarizerAgent 实现
  ├── 对话总结
  └── Artifact 更新
```

### Phase 3: MCP 封装（Week 5-6）

```
□ 3.1 MCP Server 搭建
  ├── 基础 Server 框架
  ├── Tools 注册
  └── Resources 注册

□ 3.2 集成测试
  ├── Claude Desktop 测试
  ├── Cursor 测试
  └── 端到端流程验证
```

### Phase 4: 优化与扩展（后续）

```
□ 4.1 性能优化
  ├── 缓存策略
  ├── 并发处理
  └── Token 优化

□ 4.2 高级功能
  ├── 语义搜索（向量化）
  ├── 多用户隔离
  └── 知识图谱（可选）
```

---

## 9. 与现有代码的关系

### 9.1 复用清单

| 现有文件 | 处理方式 | 说明 |
|----------|----------|------|
| `services/firestore_service.py` | ✅ **复用** | 核心数据访问层 |
| `services/artifact_service.py` | ✅ **复用** | Artifact 处理逻辑 |
| `services/llm_service.py` | ⚠️ **部分复用** | 思考配置、基础调用 |
| `models/` | ✅ **复用** | 数据模型定义 |
| `config.py` | ✅ **复用** | 配置管理 |

### 9.2 废弃清单

| 现有文件 | 处理方式 | 说明 |
|----------|----------|------|
| `tools/definitions.py` | ❌ **废弃** | MCP 有自己的定义方式 |
| `tools/executor.py` | ❌ **废弃** | 逻辑移入子代理 |
| `tools/tool_service.py` | ❌ **废弃** | 被 Orchestrator 替代 |
| `services/context_loop.py` | ❌ **废弃** | 被 MemoryAgent 替代 |
| `services/context_builder.py` | ❌ **废弃** | 被 MemoryAgent 替代 |
| `routers/chat.py` | ⚠️ **可选保留** | 如需 HTTP 接口则保留 |

### 9.3 新建文件

```
gemini-hackton/
├── agents/                     # 🆕 新建
│   ├── __init__.py
│   ├── base.py                 # 子代理基类
│   ├── orchestrator.py         # 主代理
│   ├── memory_agent.py         # 记忆代理
│   ├── archiver_agent.py       # 归档代理
│   └── summarizer_agent.py     # 总结代理
│
├── memory/                     # 🆕 新建
│   ├── __init__.py
│   ├── shared_context.py       # 共享上下文
│   ├── hot_memory.py           # 热记忆管理
│   └── cold_memory.py          # 冷记忆管理
│
├── mcp_server/                 # 🆕 新建
│   ├── __init__.py
│   ├── server.py               # MCP Server 主入口
│   ├── tools.py                # Tools 定义
│   └── resources.py            # Resources 定义
│
└── backend/app/                # 现有，部分修改
    ├── services/               # ✅ 保留
    ├── models/                 # ✅ 保留
    └── config.py               # ✅ 保留
```

---

## 📎 附录

### A. 术语表

| 术语 | 定义 |
|------|------|
| **热记忆** | 活跃的对话消息，存储在滑动窗口中 |
| **冷记忆** | 归档的知识文档（Artifacts） |
| **子代理** | 专职处理特定任务的 AI 代理 |
| **主代理** | 协调子代理的中央控制器 |
| **Artifact** | 从对话中提取的结构化知识文档 |
| **MCP** | Model Context Protocol，AI 应用的标准化接口协议 |

### B. 参考资料

- [MCP 官方文档](https://modelcontextprotocol.io/)
- [Gemini API 文档](https://ai.google.dev/gemini-api/docs)
- [Firestore 文档](https://firebase.google.com/docs/firestore)

---

> **下一步**: 确认策划书内容后，从 Phase 1 开始实现
