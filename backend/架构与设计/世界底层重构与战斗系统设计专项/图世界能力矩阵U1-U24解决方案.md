# 图世界能力矩阵 U1-U24 解决方案

> 日期: 2026-02-17（2026-02-18 更新：E3/E4/清理全部完成）
> 分支: buyu的异世界冒险
> 前置: P1-P8 解决方案已定调、C9 五路深度侦察
> 定位: 对 U1-U24（未实现项）逐项定调，按四组讨论，含代码现状调查和架构决策
>
> **实施进度（2026-02-18）**: U1-U12/U17-U24 全部完成。剩余 U13/U14/U16（新功能立项）和 U3（物品图化独立专项）。

---

## 零、贯穿性设计原则

本轮讨论确立了三条核心原则，贯穿所有 U 项的决策：

### 原则一：引擎驱动 + 状态回报

```
BehaviorEngine 是主驱动，所有状态变更自动执行；
每轮 tick 后生成结构化状态报告注入 LLM 上下文，
确保 LLM 始终掌握最新世界状态。
LLM 工具调用作为手动覆盖手段保留，不是主路径。
```

对比当前状态：

| 方面 | 当前 | 目标 |
|------|------|------|
| 事件激活 | LLM 调 `activate_event()` | 引擎根据 activation_type 自动激活 |
| 阶段推进 | 无 | 引擎 tick 检查 stage 完成条件 → 自动推进 |
| 事件完成 | LLM 调 `complete_event()` | 引擎检查条件 → 自动完成 + 选择 outcome |
| 事件失败 | 无 | 引擎超时自动 FAILED，LLM `fail_event()` 作备用 |
| 语义条件 | 永远 satisfied=True（橡皮图章） | pre-tick 挂起 → LLM 评估回报 → post-tick 判定 |

### 原则二：系统是真理源，LLM 是叙述者

```
地图数据决定能不能走、走多久、遇不遇怪；
引擎条件决定事件能不能触发、能不能完成；
LLM 只负责把结果讲成故事。
事件系统是唯一能改变地图/世界状态的途径，
而事件本身也是引擎驱动的。
```

具体表现：
- 旅行时间：引擎自动计算并推进，LLM 无权干涉
- 通行性：CONNECTS 边 `blocked=true` → navigate 直接拒绝，LLM 只能叙述"路不通"
- 遭遇率：引擎根据 `encounter_chance` 自动掷骰，LLM 只收到结果
- 事件条件：机械条件引擎自判，语义条件 FLASH_EVALUATE 请 LLM 判断后回报引擎

### 原则三：引擎先就绪，管线后升级

```
引擎侧先做到"有数据就能跑"：
  - 模型字段补全、行为生成逻辑完善、工具层接入
当前 323 个事件的 stages/outcomes/activation_type 等数据全空，
管线升级后补数据，引擎无需再改。
```

### 当前 LLM 信息回报管道的缺口

引擎 → LLM 的结构化信息注入是闭环的关键环节，当前覆盖不足：

| 信息维度 | 现状 | 应该有 | 关联 U/P |
|---------|------|--------|---------|
| 事件摘要 | id/name/status/importance | + stage 进度、objectives、completion_hint | P10, U4 |
| 引擎本轮动作 | narrative_hints（文本） | + 结构化动作日志 | — |
| pending_flash 语义条件 | 断链，LLM 收不到 | 完整注入，LLM 评估后回报 | U7 |
| world_flags | 不存在 | 当前世界标记状态 | U17, U20 |
| 区域动态 | 部分 | + NPC 位置/状态、环境变化 | U16 |

---

## 组 A：事件生命周期（U4-U12）

### 全景：事件状态机

设计为 **6 态**，当前实际只走 **4 态**：

```
设计:  LOCKED → AVAILABLE → ACTIVE → COMPLETED
                                   ↘ FAILED → COOLDOWN → AVAILABLE (重复)

实际:  LOCKED → AVAILABLE → ACTIVE → COMPLETED  （FAILED/COOLDOWN 不可达）
```

代码现状调查结果（2026-02-17 更新）：
- **EventStage / EventOutcome / EventObjective** — ✅ 模型已统一归属 `narrative.py`，graph_builder 消费完整
- **`complete_event()`** — ✅ 支持 `outcome_key` 参数 + 条件验证 + 状态回滚 + outcome 特定奖励
- **`complete_event_objective()`** — ✅ 新增事件级 objective 完成工具（区别于章节级 `complete_objective`）
- **`advance_stage()`** — ✅ 新增手动阶段推进工具 + required objectives 校验
- **`_event_to_behaviors()`** — ✅ 生成 4 类行为（unlock + stage推进 + complete + outcome判定），均含 EVENT_STATE 状态守卫
- **pending_flash** — 引擎产出但管线未注入上下文（U7 待做）
- **FAILED / COOLDOWN** — 枚举值零引用（U9/U10 待做）

---

### 一、U4 + U5 + U6 + U21 + U22：事件结构化 ✅ 已完成

> U21（event_def properties 缺失）和 U22（event_def state 初始化不完整）与 U4/U5 强耦合，一并处理。
>
> **实施完成**: 2026-02-17。改动 10 个文件，新增 29 个测试。实施记录见 `~/.claude/plans/flickering-sauteeing-galaxy.md`。
> 实施后经 Codex 审查，修复 5 项问题（ConditionGroup operator 保留、静态方法修正、补偿 tick 同步、unlock_events 处理、条件优先级）。

#### 1.1 U4: EventStage 主流程化

**现状**：
- `EventStage` 模型存在（models.py）：含 objectives + completion_conditions + narrative_directive
- graph_builder 不生成阶段推进行为
- 事件节点 state 只有 `{"status": "locked"}`，无 `current_stage`/`stage_progress`

**解决方案**：

graph_builder 为有 stages 的事件生成阶段推进行为（设计文档 6.3 已有规格）：

```python
# 每个 stage 转换 = 一个 Behavior (once=True)
Behavior(
    id=f"{event_id}_stage{i}to{i+1}",
    trigger=TriggerType.ON_TICK,
    conditions=ConditionGroup(conditions=stage.completion_conditions),
    actions=[Action(type=ActionType.CHANGE_STATE, params={
        "target": event_id,
        "updates": {"current_stage": next_stage_id}
    })],
    once=True,
    priority=5,
)
```

引擎 tick 自动检查 stage 完成条件 → 自动推进。LLM 不需要介入。

**新工具 `advance_stage(event_id, stage_id)` (U11)**：手动覆盖手段，含 required objectives 校验，不是主路径。

#### 1.2 U5: EventOutcome 主流程化

**现状**：
- `EventOutcome` 模型存在：含 conditions + rewards + reputation_changes + world_flags + unlock_events
- `complete_event()` 无 outcome_key 参数，无条件验证，无 outcome 特定奖励

**解决方案**：

**混合判定机制**（设计文档 6.4 已定义）：

| 判定方式 | 例子 | 机制 |
|---------|------|------|
| Behavior 自动 | 时间耗尽→failure / 怪物全灭→victory | ON_TICK / ON_EVENT behavior |
| LLM 工具调用 | 杀死 vs 放走哥布林（玩家选择） | `complete_event(event_id, outcome_key)` |

改造 `complete_event()`：
1. 新增 `outcome_key` 参数（可选）
2. 如果 outcome 有 `conditions`，校验是否满足，不满足则拒绝
3. 应用 outcome 特定奖励：`rewards`（xp/gold/items）、`reputation_changes`、`world_flags`、`unlock_events`
4. 每个 outcome 的 conditions 也可以包含 FLASH_EVALUATE（语义判定）

**结局验证**：每个 outcome 带 `conditions: ConditionGroup`，LLM 调用时必须满足，否则拒绝。必须有至少一个 `conditions=null` 的 fallback outcome。

#### 1.3 U6: EventObjective 追踪

**现状**：
- `complete_objective()` 更新 narrative 但不更新 `event_def.state.objective_progress`
- 不触发 stage 完成条件检查

**解决方案**：
- `complete_objective()` 同时写回 `event_def.state.objective_progress`
- 写回后自然触发下一轮 tick 的 stage 完成条件评估
- 上下文输出加 objective 进度列表（P10 联动）

#### 1.4 U21: event_def properties 补全

**现状**（graph_builder.py:507-519）：

evt_props 只传了 8 个字段，设计要求的 10 个字段未传：

| 缺失字段 | 数据来源 | 管线数据现状 |
|---------|---------|------------|
| `activation_type` | StoryEvent | 全空 |
| `visibility` | StoryEvent | 全空 |
| `discovery_check` | StoryEvent | 全空 |
| `quest_giver` | StoryEvent | 全空 |
| `time_limit` | StoryEvent | 全空 |
| `related_events` | StoryEvent | 全空 |
| `stages` | StoryEvent | 全空 |
| `outcomes` | StoryEvent | 全空 |
| `repeat_cooldown` | StoryEvent（现为 `cooldown_rounds`） | 全 0 |
| `recommended_level` | StoryEvent | 全空 |

**解决方案**：graph_builder 中透传所有字段到 evt_props。字段为空/None 时不传（保持稀疏）。引擎先就绪，管线升级后数据自动生效。

#### 1.5 U22: event_def state 初始化补全

**现状**（graph_builder.py:529）：

```python
state={"status": EventStatus.LOCKED}  # 只有这一个字段
```

**设计要求的初始 state**：

```python
state={
    "status": EventStatus.LOCKED,
    "discovered": False,             # discovery 激活方式使用
    "current_stage": None,           # 当前阶段 ID
    "stage_progress": {},            # {stage_id: "locked"/"active"/"completed"}
    "objective_progress": {},        # {objective_id: True/False}
    "outcome": None,                 # 最终选择的 outcome_key
    "activated_at_round": None,      # 激活时的回合数（超时计算用）
    "rounds_elapsed": 0,            # 事件级回合计数（不同于章节级 round_count）
    "repeat_count": 0,              # 已重复次数
}
```

**解决方案**：graph_builder 建事件节点时补全初始 state。大部分字段初始为 None/0/空，不增加存储负担。

---

### 二、U7 + U12：pending_flash 闭环

#### 2.1 当前链路（断裂）

```
引擎 tick → 遇到 FLASH_EVALUATE 条件
  → _eval_flash_evaluate() 返回 satisfied=True + pending_flash  ← 橡皮图章
    → pending_flash 产出了 ✅
      → pipeline_orchestrator 没注入上下文 ❌
        → FlashCPU 期待收但永远收不到 ❌
          → 没有回报机制 ❌
            → post-tick 无法用结果重评估 ❌
```

**代码依据**：

产出端（behavior_engine.py:243-252）：
```python
def _eval_flash_evaluate(cond: Condition, ctx: TickContext) -> EvalResult:
    return EvalResult(
        satisfied=True,       # ← 直接放行，语义条件永远通过
        pending_flash=[cond],
        details={"flash_evaluate": True},
    )
```

消费端（pipeline_orchestrator.py:96-109）：
```python
pre_tick_result = session.run_behavior_tick("pre")
context = ContextAssembler.assemble(world, session)
context_dict = context.to_flat_dict()
# 只注入了 narrative_hints，pending_flash 被丢弃
if pre_tick_result and pre_tick_result.narrative_hints:
    context_dict["world_graph_hints"] = pre_tick_result.narrative_hints
# ❌ 没有: context_dict["pending_flash_conditions"] = pre_tick_result.pending_flash
```

FlashCPU（flash_cpu_service.py:339-347）期待 `context.get("pending_flash_conditions")` 但永远拿到空。

#### 2.2 解决方案：当轮闭环（方案 A）

**关键决策**：利用管线的 A→B→C 三阶段结构，在**同一回合内**完成 pending_flash 的完整生命周期：

```
A4: pre-tick
  → 引擎遇到 FLASH_EVALUATE → 返回 satisfied=False + pending_flash
  → 行为暂不执行（条件未满足）
  → pending_flash 收集到 pre_tick_result
    ↓
A4→B: 注入上下文
  → pipeline_orchestrator 将 pending_flash 注入 context_dict
    ↓
B: agentic 会话
  → LLM 看到 pending_flash 条件描述
  → LLM 根据对话历史判断
  → LLM 调用 report_flash_evaluation(condition_id, result) 回报
  → 结果存入 session 级缓存
    ↓
C6: post-tick
  → 引擎重新评估含 FLASH_EVALUATE 的行为
  → 查缓存拿到 LLM 判定结果
  → 条件真正满足 → 触发动作
  → 条件不满足 → 行为不触发
```

**关键改动**：

1. **`_eval_flash_evaluate()` 改为 `satisfied=False`**（不再橡皮图章放行）
2. **pipeline_orchestrator** 从 pre_tick_result 取 pending_flash → 注入 context_dict
3. **新工具 `report_flash_evaluation(condition_id, result, reason)` (U12)**
   - 结果存入 `session.flash_results: Dict[str, bool]`
   - 缓存在会话生命周期内有效
4. **post-tick 时引擎查缓存**：`_eval_flash_evaluate()` 先查缓存，有结果直接用，无结果才标 pending

#### 2.3 为什么是方案 A（当轮）而非方案 B（下轮）

管线本身就是 pre-tick → agentic → post-tick 的三阶段结构。pre-tick 标记需要评估的条件，agentic 阶段 LLM 评估并回报，post-tick 拿结果做最终判定——全部在一个回合内完成，不需要延迟。

方案 B（下轮生效）之前考虑的"当轮撤销已执行动作很复杂"的问题不存在——因为改为 `satisfied=False` 后，行为在 pre-tick 根本不会执行，不需要撤销。

---

### 三、U8：activation_type 行为生成 ✅ 已完成（E4）

> **实施完成（2026-02-18）**：见 E4 实施记录

#### 3.1 设计：四种激活方式

原设计文档（世界图数据模型设计 6.2）定义了 4 种激活方式，分别映射到**不同的** BehaviorEngine 触发器类型：

| activation_type | 含义 | 引擎机制 | 示例 |
|----------------|------|----------|------|
| `npc_given` | NPC 对话中交付 | 不生成自动行为，LLM 调 `activate_event()` | 公会女孩发布任务 |
| `auto_enter` | 进入区域自动激活 | ON_ENTER behavior | 进矿洞触发坍塌 |
| `event_driven` | 被前置事件链驱动 | ON_EVENT behavior | 前置任务完成 → 本任务解锁 |
| `discovery` | 探索发现型，需检定 | ON_ENTER + discovery_check 条件 | 发现隐藏地下室 |

**当前代码**（graph_builder.py `_event_to_behaviors()`）对所有事件统一生成 ON_TICK 行为，把 4 种语义打平成一种轮询。

#### 3.2 解决方案

graph_builder 根据 `activation_type` 生成对应行为：

```python
match activation_type:
    "npc_given"    → 不生成 unlock 行为（纯手动）
    "auto_enter"   → unlock 行为 trigger=ON_ENTER
    "event_driven" → unlock 行为 trigger=ON_EVENT（响应前置事件 EMIT_EVENT）
    "discovery"    → unlock 行为 trigger=ON_ENTER + discovery_check 条件
    缺失/默认      → 保持现有 ON_TICK（向后兼容）
```

#### 3.3 断裂点

| 断裂点 | 说明 | 处理方式 |
|--------|------|---------|
| **P1 依赖** | auto_enter 和 discovery 都依赖 ON_ENTER，而 navigate() 当前不调 handle_enter() | P1 修复后自动生效 |
| **discovery 检定机制** | `discovery_check: {"skill": "perception", "dc": 15}` 需要技能检定条件类型，当前 9 种条件类型里没有 | 待实施时决定：新增条件类型 or 用 FLASH_EVALUATE 承载 |
| **数据源全空** | 323 个事件的 activation_type 全空 | 缺失时默认保持 ON_TICK（向后兼容），管线升级后生效 |

---

### 四、U9 + U10 + U11：失败/超时/冷却 + 新工具

#### 4.1 U9: 失败与冷却机制

**三种失败路径**（设计文档 6.5）：

| 路径 | 机制 | 引擎/手动 |
|------|------|----------|
| 超时 | ON_TICK behavior: `rounds_elapsed >= time_limit` | 引擎自动 |
| 条件破坏 | ON_EVENT behavior: `entity_killed(quest_giver)` | 引擎自动 |
| LLM 判定 | `fail_event(event_id, reason)` 工具 | 手动覆盖 |

**超时行为**（graph_builder 生成）：
```python
# 有 time_limit 的事件自动生成
Behavior(
    id=f"{event_id}_timeout",
    trigger=TriggerType.ON_TICK,
    conditions=ConditionGroup(conditions=[
        Condition(type="event_status", params={"event_id": event_id, "status": "active"}),
        Condition(type="event_rounds_elapsed", params={"event_id": event_id, "min_rounds": time_limit}),
    ]),
    actions=[Action(type=ActionType.CHANGE_STATE, params={
        "target": event_id,
        "updates": {"status": "failed"}
    })],
    once=True,
)
```

**可重复事件冷却**（设计文档 6.6）：

`is_repeatable=True` 的事件，COMPLETED/FAILED 后进入 COOLDOWN：
```python
Behavior(
    id=f"{event_id}_cooldown_reset",
    trigger=TriggerType.ON_TICK,
    conditions=ConditionGroup(conditions=[
        Condition(type="event_status", params={"event_id": event_id, "status": "cooldown"}),
        Condition(type="event_rounds_elapsed", params={"event_id": event_id, "min_rounds": cooldown_rounds}),
    ]),
    actions=[Action(type=ActionType.CHANGE_STATE, params={
        "target": event_id,
        "updates": {
            "status": "available",
            "current_stage": None,
            "stage_progress": {},
            "objective_progress": {},
            "outcome": None,
            "rounds_elapsed": 0,
        }
    })],
    # once=False — 可重复触发
)
```

冷却重置还需要**重新启用所有 once behaviors**（清除 behavior_fired 标记）。

**失败后果**：如果 EventOutcome 定义了失败结局（如 outcome_key="failure"），fail_event 自动应用该 outcome 的 rewards（可能是负面的），与 complete_event(outcome_key) 对称。

#### 4.2 断裂点（代码调查发现）

| 断裂点 | 现状 | 修复方案 |
|--------|------|---------|
| **round_count 语义** | `_eval_rounds_elapsed()` 用 `ctx.round_count`（章节级总回合数），不是事件激活后经过的回合数 | 新增 `event_rounds_elapsed` 条件类型，读 `event_def.state.activated_at_round` 计算差值 |
| **once behaviors 无重置 API** | `WorldNode.mark_behavior_fired()` 永久标记，无清除机制 | 新增 `reset_behaviors(node_id)` 方法，清除 behavior_fired 列表 |
| **graph_builder 漏传字段** | `cooldown_rounds`、`time_limit` 未进 evt_props | 透传到 properties（U21 一并处理） |
| **complete_event 无 COOLDOWN** | 完成后不检查 is_repeatable，不转 COOLDOWN | 补充：完成/失败后检查 is_repeatable → 转 COOLDOWN + 记录时间戳 |

#### 4.3 U10: 新工具 `fail_event(event_id, reason)`

LLM 在判断玩家彻底搞砸时调用（如杀了任务 NPC、摧毁关键物品）。手动覆盖手段，不是主路径。

```python
async def fail_event(self, event_id: str, reason: str = "") -> Dict[str, Any]:
    # 1. 校验事件状态为 ACTIVE
    # 2. 设置状态为 FAILED
    # 3. 如果有 failure outcome → 应用 outcome rewards（可能是负面的）
    # 4. 如果 is_repeatable → 转 COOLDOWN
    # 5. 发射 WorldEvent(event_type="event_failed")
    # 6. 级联触发（和 complete_event 对称）
```

#### 4.4 U11: 新工具 `advance_stage(event_id, stage_id)` ✅ 已完成

手动推进事件阶段。校验 required objectives 是否全部完成。

**已实现** (`v4_agentic_tools.py`):
- `advance_stage(event_id, stage_id="")` — stage_id 为空时推进到下一个
- 校验 required objectives 全部完成
- 更新 `current_stage` + `stage_progress`
- 最后一个 stage → 自动调 `complete_event()`
- 补偿 tick + `_sync_tick_to_narrative`

主路径靠引擎 tick 自动推进（U4 的阶段推进行为），此工具为手动覆盖。

---

## 组 B：实体与世界状态（U1-U3, U17-U19）

### 五、U1: ON_STATE_CHANGE 触发器 ✅ 已完成（E5.2）

> **实施完成（2026-02-17 随 E3 一并完成）**

#### 5.1 现状（已解决）

**快照系统调查**（snapshot.py）：只捕获最终状态（dirty node states），不记录 before/after diff。不支持 ON_STATE_CHANGE 的回放。

#### 5.2 解决方案

**核心改动**：在 `merge_state`/`set_state` 中记录 state diff：

```python
# world_graph.py
def merge_state(self, node_id: str, updates: Dict[str, Any]) -> None:
    node = self.get_node(node_id)
    # 记录变更前的值
    old_values = {k: node.state.get(k) for k in updates if node.state.get(k) != updates[k]}
    node.merge_state(updates)
    self._dirty_nodes.add(node_id)
    # 记录 diff 供 tick 使用
    if old_values:
        self._state_diffs.setdefault(node_id, []).append({
            "old": old_values,
            "new": {k: updates[k] for k in old_values},
        })
```

**引擎侧**：tick 时检查累积的 state_diffs，对有 ON_STATE_CHANGE + 匹配 watch_key 的行为触发评估：

```python
# behavior_engine.py
def _eval_state_change_behaviors(self, ctx: TickContext) -> TickResult:
    diffs = self.wg.get_and_clear_state_diffs()
    for node_id, diff_list in diffs.items():
        node = self.wg.get_node(node_id)
        for bh in node.get_active_behaviors(TriggerType.ON_STATE_CHANGE):
            if bh.watch_key in changed_keys:
                # 评估条件 + 执行动作
```

**用途场景**：
- NPC `is_alive: true → false` → 触发死亡事件
- 区域 `danger_level` 升高 → 触发警报行为
- Player `hp` 降到 0 → 触发倒地事件

---

### 六、U2: Player 节点建图 — ✅ 已完成（2026-02-17）

> **实施记录**：详见 `app/world/player_node.py`、`tests/test_player_node_view.py`、`tests/test_c7_integration.py` (TestU2*)

已落地内容：

- **PlayerNodeView 适配器**（`player_node.py`）：包装 WorldGraph 节点提供 PlayerCharacter 兼容 API，~15 属性读写 + dirty 标记 + inventory CRUD + to_summary_text/to_combat_player_state/model_dump
- **translate_character_to_node()**：PlayerCharacter → (state, properties) 转换，字段映射 + spell_slots int↔str 转换
- **graph_builder `_build_player_node()`**：构图时创建 PLAYER 节点 + MEMBER_OF(player→camp) + HOSTS(location→player) 边
- **SessionRuntime.player 属性**：优先从 WorldGraph 返回 PlayerNodeView，降级到 _player_character
- **persist() 不再调 character_store.save_character()**：player dirty 节点通过 snapshot 统一持久化
- **战斗同步**：`_sync_combat_to_graph()` 写 HP/XP/gold/items 到 player 图节点
- **FlashCPU `sync_combat_result_to_character()`**：新增 session 参数，有 session → 图路径，无 session → 旧 character_store 兼容路径
- **测试**：19 (PlayerNodeView) + 12 (C7 集成 U2) = 31 tests，全部通过

---

### 七、U3: HAS_ITEM 物品图化（P1-P8 已定调延后）

详见 **P1-P8 解决方案 § P7 物品系统决策**。核心要点：

- **当前**：方案 A — inventory 作为 player 节点 state 中的列表
- **待做**：方案 B — 物品图化（独立设计专项）
  - 每个物品实例为独立节点，HAS_ITEM 边连接持有者
  - 支持物品行为、场景拾取、物品转移
  - 需独立设计 quantity 建模、模板 vs 实例、loot_containers

---

### 八、U17 + U18 + U19：世界状态系统 ✅ 已完成（P7 + 本轮清理）

> **2026-02-18 更新**：U17/U18/U20（context 注入部分）本轮清理全部完成。详见改动 2。
>
> **P7 进展更新（2026-02-17）**：P7 已实现副作用处理和存储的核心部分：
> - U17 world_flags：写入 `world_root.state.world_flags` ✅（P7 session_runtime + v4_agentic_tools）
> - U18 声望：写入 `world_root.state.faction_reputations` ✅（P7，存储位置改为 world_root 而非 player）
> - U19 金币：通过 `player.gold` (PlayerNodeView) 写图 ✅（P7 + U2）
> - 剩余：TickContext 填充 world_flags（P9）、context_assembler 注入（U20）、EventOutcome 联动（U5）

这三个本质相同：**模型字段设计好了，副作用处理器没接上，存储位置没定**。一旦 U2（Player 入图）+ U5（EventOutcome）实现，这三个自然就有了归宿。

#### 8.1 U17: world_flags 持久化

**现状**（P7 更新后）：
- `TickContext.world_flags` 字段存在（models.py:384）— **永远空 dict**（P9 待填充）
- `EventOutcome.world_flags` 字段存在（models.py:238）— 设计了 outcome 设置标记，但 outcome 未实现（U5）
- ✅ **存储已实现**：P7 写入 `world_root.state.world_flags`
- ✅ **副作用处理已实现**：`_apply_tick_side_effects` + `_apply_on_complete_from_graph` 处理 `world_flag_set` 事件
- ❌ **TickContext 填充**：`build_tick_context()` 未从 world_root 读 world_flags（P9）
- ❌ **上下文注入**：context_assembler 未注入（U20）

**剩余工作**：
- P9: `build_tick_context()` 从 world_root 节点读 world_flags 填入 TickContext
- U20: context_assembler 的 chapter_context 加入 world_flags 段

#### 8.2 U18: faction_reputations 声望系统

**现状**（P7 更新后）：
- `EventOutcome.reputation_changes` 字段存在（models.py:232）— `{"adventurer_guild": +10}`
- ✅ **存储已实现**：P7 写入 `world_root.state.faction_reputations`（注：存储位置选择 world_root 而非 player，因为声望是世界级状态）
- ✅ **副作用处理已实现**：`_apply_tick_side_effects` + `_apply_on_complete_from_graph` 处理 `reputation_changed` 事件
- ❌ **上下文注入**：未通过 context_assembler 暴露给 LLM

**剩余工作**：
- 上下文组装时从 world_root 节点读取 faction_reputations 注入

#### 8.3 U19: party_gold 金币系统

**现状**（P7 + U2 更新后）：
- ✅ **存储已实现**：Player 图节点 `state.gold`，通过 `PlayerNodeView.gold` 读写（U2 Player 入图）
- ✅ **战斗金币**：`_sync_combat_to_graph` 写 player 图节点（P6/U2）
- ✅ **事件金币**：`_apply_tick_side_effects` + `_apply_on_complete_from_graph` 处理 `gold_awarded` 事件（P7）
- ✅ **graph_builder 生成**：`on_complete.add_gold` → EMIT_EVENT(gold_awarded)（P7）

**状态：✅ 核心功能已完成**，金币存储/读写/事件发放全链路可用。

#### 8.4 三项依赖关系

```
U2 (Player 入图) ──→ U18 (声望存到 player.state)
                  ──→ U19 (金币存到 player.state)

U5 (EventOutcome) ──→ U17 (world_flags 由 outcome 设置)
                   ──→ U18 (reputation_changes 由 outcome 触发)
                   ──→ U19 (gold 由 outcome rewards 触发)
```

---

## 组 C：导航高级（U13-U15）

### 九、U13: 快速旅行 waypoint

**现状**：`is_waypoint` 在整个 app 目录中零匹配，连字段都不存在。

**定调**：按原设计文档方向，本轮修复后作为**新功能立项**，加入文档。当前不实施。

**设计要点**（来自数据模型设计文档）：
- 到过的安全区域可标记为 waypoint
- 快速旅行跳过中间路程但消耗物资
- 可能触发遭遇检定
- 系统自动计算时间推进（引擎驱动，LLM 无权干涉）

---

### 十、U14: 营地导航 return_location

**现状**：`return_location` 在 app 代码中零匹配，只在设计文档中存在。

**设计文档规格**（世界图数据模型设计 7.4）：
```
进入营地:
  - 任何位置都可以 → camp 节点
  - camp.state.return_location = player 当前 location
  - camp.state.return_area = player 当前 area

离开营地:
  - 返回 return_location
  - ON_ENTER 触发（如果有新的 behaviors）
```

**定调**：扩展为**营地系统**——整合角色私聊、同伴单独对话、角色事件等功能。作为独立设计专项，后续单独设计实施。当前不实施。

---

### 十一、U15: CONNECTS 边丰富属性

**现状**：

graph_builder（479-487）建 CONNECTS 边时传了 3 个属性：`connection_type`、`travel_time`、`requirements`。

| 属性 | 现状 | 性质 |
|------|------|------|
| `description` | AreaConnection 模型有，graph_builder 未传到边上 | **断裂**（一行修复） |
| `encounter_chance` | 模型不存在，area_navigator 按 danger_level 硬编码 | **新增**（模型扩展 + 数据源依赖） |
| `blocked` / `blocked_reason` | 完全不存在 | **新增**（模型扩展 + 数据源依赖） |
| `travel_time` 字符串→数值 | 当前为字符串 "30 minutes"，每次要 parse | **设计不一致**（数值化消除 parse） |

**各属性作用**：
- `description`：连接的文字描述，LLM 旅行叙述素材
- `encounter_chance`：per-edge 遭遇概率，引擎自动掷骰（系统真理源）
- `blocked`/`blocked_reason`：道路封锁，navigate 直接拒绝通行（系统真理源），事件可动态修改
- `travel_time` 数值化：引擎直接消费，消除字符串解析

**定调**：
- `description` 断裂：graph_builder 补传，随 P8 一起修
- 其余属性：和 P8（navigate 从图读 CONNECTS 边）一起做，先在代码中预留检查骨架，等管线/数据补充后生效
- 所有导航属性遵循"系统是真理源"原则：引擎自动计算时间、自动判定通行、自动掷骰遭遇，LLM 无权干涉

---

## 组 D：构图与模型补全（U16, U21-U24）

### 十二、U16: NPC 日程 → Behavior 转换

**现状**：
- NPC state 有 `"schedule": "morning"`（constants.py:290）— 只是字符串标记
- 无表结构、无时间段定义、无行为生成、无 NPC 移动逻辑
- 纯空白，新功能

**定调**：低优先级，Sprint 5 处理。P1-P8 已标记延后。

**设计方向**：
- NPC 角色数据中定义 schedule_table：`[{hour_range: [8,12], location: "market"}, ...]`
- graph_builder 为有 schedule 的 NPC 自动生成 ON_TIME 行为
- 到点了引擎自动移动 NPC（修改 HOSTS 边指向新位置）
- 和 P3（时间跳跃盲区）一并解决

---

### 十三、U21 + U22: event_def 补全 ✅ 已完成

见 **§ 1.4 U21** 和 **§ 1.5 U22**。与 U4/U5 强耦合，已一并实施（2026-02-17）。

---

### 十四、U23: WorldEvent.actor 死字段 ✅ 已完成（本轮清理）

> **实施完成（2026-02-18）**：`activate_event`/`complete_event`/`fail_event` 创建 WorldEvent 时补 `actor="player"`；`combat_ended` 已有。`event_completed.data` 加 `source` 字段（manual/tool）区分手动选择结局 vs 工具直接完成。`_exec_emit_event`（系统自动触发）保持 actor="" 不变。

---

### 十五、U24: TickContext.session ✅ 已使用

**已实施**（2026-02-17，随 U4 一并完成）：
- `build_tick_context()` 传入 `session=self`
- `_eval_event_state()` 条件处理器通过 `ctx.session.world_graph` 访问图节点状态
- 这是 EVENT_STATE 条件类型的核心依赖——检查事件节点的运行时 state 字段

---

## 十六、依赖图与执行顺序

### 依赖关系

```
U2 (Player 入图) ✅ 已完成
  ├─→ U17 (world_flags): world_root.state 存储
  ├─→ U18 (reputation): player.state 存储 — U2 依赖已就绪
  ├─→ U19 (gold): player.state 存储 — U2 依赖已就绪
  └─→ U1 (ON_STATE_CHANGE): Player 节点 state 变更可触发行为

U4 (EventStage) + U5 (EventOutcome) + U6 (Objective) ✅ 已完成
  ├─→ U21 (properties 补全): ✅ 一并实施
  ├─→ U22 (state 初始化): ✅ 一并实施
  ├─→ U11 (advance_stage): ✅ 一并实施
  ├─→ U24 (session): ✅ 一并实施 (EVENT_STATE 条件需要)
  ├─→ P10 (事件摘要): ✅ 一并实施
  ├─→ U17 (world_flags): outcome 设置 flags — U5 依赖已就绪
  ├─→ U18 (reputation): outcome 触发声望变更 — U5 依赖已就绪
  └─→ U19 (gold): outcome 触发金币奖励 — U5 依赖已就绪

U7 (pending_flash) + U12 (report_flash_evaluation)
  → 独立，无前置依赖

U8 (activation_type)
  ├─→ 依赖 P1 ✅ (handle_enter/exit): auto_enter/discovery 需要 ON_ENTER
  └─→ discovery 检定机制待定

U9 (失败/冷却) + U10 (fail_event)
  ├─→ 依赖 U4/U5 ✅: 阶段/结局模型已就绪
  └─→ 引擎扩展: event_rounds_elapsed 条件 + once 重置 API

U1 (ON_STATE_CHANGE)
  → 独立，无前置依赖（但实际触发场景依赖其他 U 的 state 变更）

U13 (waypoint) → 新功能立项，本轮不实施
U14 (营地系统) → 扩展设计，本轮不实施
U15 (CONNECTS 属性) → 随 P8 修复 description 断裂，其余随管线
U16 (NPC 日程) → Sprint 5，本轮不实施
U23 (actor) → 顺手修
```

### 建议执行顺序（2026-02-18 更新完成状态）

```
第一步（事件基础设施）— ✅ 全部完成:
  ✅ U2                Player 入图（31 tests）
  ✅ U4/U5/U6 + U21/U22 + U11 + U24 + P10  事件结构化（29 tests + Codex 审查修复）
  ✅ U7 + U12          pending_flash 闭环（E3）
  ✅ U1                ON_STATE_CHANGE（E5.2，8 tests）

第二步（事件完整能力）— ✅ 全部完成:
  ✅ U8                activation_type 行为生成（E4，6 tests）
  ✅ U9 + U10          失败/超时/冷却 + fail_event 工具（E4，10 tests）
  ✅ U17/U18/U20       世界状态系统注入 context（本轮清理）

第三步（清理 + 小修）— ✅ 全部完成:
  ✅ U15               CONNECTS description 断裂修复（P8）
  ✅ U23               WorldEvent.actor 填充（本轮）
  ✅ P9/P11            TickContext 补全 + 条件摘要（本轮）

第四步（新功能，后续立项）:
  U13                  快速旅行 waypoint
  U14                  营地系统（扩展设计）
  U16                  NPC 日程系统
  → 下一阶段重点：管线升级（lorebook 完整内容提取）
```

---

## 十七、验证标准

### 功能验证

| 验证项 | 预期行为 |
|--------|---------|
| EventStage 自动推进 | 阶段条件满足 → tick 自动推进到下一阶段 |
| EventOutcome 自动判定 | outcome 条件满足 → 引擎选择对应结局 + 应用奖励 |
| objective 追踪回写 | `complete_objective()` → event_def.state.objective_progress 更新 |
| pending_flash 当轮闭环 | pre-tick 标 pending → LLM 评估 → post-tick 用结果判定 |
| activation_type 区分 | npc_given 不自动激活 / auto_enter 进入时激活 / event_driven 事件驱动 |
| 事件超时 | ACTIVE 事件超过 time_limit → 自动 FAILED |
| 事件冷却重置 | is_repeatable 事件完成 → COOLDOWN → 冷却到期 → AVAILABLE + 进度重置 |
| fail_event 工具 | 调用后事件 FAILED + 应用失败 outcome + 可能进入 COOLDOWN |
| advance_stage 校验 | required objectives 未完成时拒绝推进 |
| ON_STATE_CHANGE | merge_state 改变 NPC is_alive → 触发 ON_STATE_CHANGE 行为 |
| world_flags 持久化 | outcome 设置 flags → world_root.state 更新 → TickContext 可读 |
| reputation 变更 | outcome reputation_changes → player.state.reputations 更新 |
| gold 应用 | gold_awarded 事件 → player.state.gold 增加 |
| WorldEvent.actor | 事件创建时 actor 字段正确填充 |

### 回归验证

- 现有 196 个测试全部通过
- 新增 U 系列相关测试用例
- activation_type 缺失时默认行为与当前一致（向后兼容）
- pending_flash 无条件时行为与当前一致
- 快照恢复后事件状态（stage/objective/rounds_elapsed）一致性
