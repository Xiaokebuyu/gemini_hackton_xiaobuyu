# 图世界能力矩阵 P1-P8 解决方案

> 日期: 2026-02-16
> 分支: buyu的异世界冒险
> 前置: C8 BehaviorEngine 全面切换、C9 五路深度侦察
> 定位: 对 P1-P8（部分实现项）逐项定调，含根因分析和架构级修正

---

## 零、贯穿性架构问题：双轨数据源

### 现状

运行时存在两套并行数据源，部分代码读旧系统，部分读新系统：

```
旧系统（WorldInstance 静态注册表）                新系统（WorldGraph 运行时图）
────────────────────────────────                ──────────────────────────────
area_registry   → AreaDefinition                 area 节点 + CONNECTS 边
chapter_registry → chapter dict                  chapter 节点 + GATE 边
character_registry → 角色 dict                   npc 节点 + HOSTS 边
PlayerCharacter (Pydantic)                       ✅ player 节点（U2 已完成）
graph_store.disposition (Firestore 独立路径)       npc.state.dispositions（初始后不更新）
character_store (Firestore 独立路径)               ✅ persist() 不再调 character_store（U2 已完成）
```

### 运行时代码对旧注册表的引用（需迁移）

| 文件 | 方法 | 行号 | 读取的旧数据源 | 应改为 |
|------|------|------|--------------|--------|
| session_runtime.py | `enter_area()` | 616 | `world.get_area_definition(area_id)` | 从图读 area 节点 |
| session_runtime.py | `_restore_area()` | 274 | `world.get_area_definition()` | 从图读 area 节点 |
| session_runtime.py | `_apply_tick_side_effects()` | 469-481 | `self.player.xp` / `player.inventory` | 写 player 图节点 state |
| session_runtime.py | `persist()` | 772-777 | `character_store.save_character()` | 快照统一持久化 |
| v4_agentic_tools.py | `navigate()` | 346-353 | `self.area.definition.connections` | 从图读 CONNECTS 边 |
| v4_agentic_tools.py | `_resolve_area_id()` | 436-444 | `world.area_registry` | 从图查询 |
| v4_agentic_tools.py | `update_disposition()` | 1620 | `graph_store.update_disposition()` | 写 NPC 图节点 state |
| v4_agentic_tools.py | `sync_combat_result_to_character()` | 1036 | `character_store` | 写 player 图节点 state |
| context_assembler.py | `_get_chapter_context()` | 40, 56-57, 178 | `mainline_registry` / `chapter_registry` | 从图读 chapter 节点 |
| context_assembler.py | `assemble()` | 232-244 | `character_registry.items()` | 从图查询 NPC 节点 |
| context_assembler.py | `_build_dynamic_state()` | 278-282 | `session.player.model_dump()` | 从 player 图节点读 |
| area_runtime.py | `get_area_context()` | 365-371 | `world.get_characters_in_area()` | 从图查询 HOSTS 边 |

### 不需要迁移的（静态参考数据，不参与行为引擎）

| 注册表 | 用途 | 保留理由 |
|--------|------|---------|
| `monster_registry` | 战斗怪物模板（HP/AC/技能） | 纯参考数据，不是图节点 |
| `skill_registry` | 技能描述和数据 | 纯参考数据 |
| `item_registry` | 物品模板（类型/稀有度/描述） | 纯参考数据（未来物品图化后可能迁移） |

### 修正原则

```
定义层（类型/Schema/行为模板）  → 代码中定义
实例层（具体节点/边/状态）      → 运行时仅存在于 WorldGraph 内存态
持久化                         → 通过 Snapshot 统一写入 Firestore
静态参考数据（不参与行为引擎）  → 注册表保留
```

---

## 一、P1: ON_ENTER/ON_EXIT 运行时触发 — ✅ 已完成（2026-02-17）

### 根因

`navigate()` (v4_agentic_tools.py:308-423) 成功切换区域后，**未调用** `behavior_engine.handle_enter()` / `handle_exit()`。仅更新了 `visited` 和 `visit_count`。

### 引擎侧现状（无需修改）

- `behavior_engine.py:699-713` — `handle_enter()` / `handle_exit()` 实现完整
- `_handle_location_trigger()` (line 879-928) 正确遍历 scope chain + 实体节点，评估对应 behaviors，传播事件

### 解决方案

**前置：Player 节点入图（见下方 P1-附：Player 入图专项）**

在 `navigate()` 成功后新增：

```
1. 记录 old_area_id（切换前）
2. handle_exit("player", old_area_id, ctx)    ← 离开旧区域
3. 执行区域切换
4. handle_enter("player", new_area_id, ctx)   ← 进入新区域
5. 处理两个 TickResult:
   - narrative_hints → 注入返回结果
   - all_events → 副作用处理
   - state_changes → 应用
6. 更新 player 节点 HOSTS 边: 旧位置移除 → 新位置添加
7. 更新队友 NPC 节点 HOSTS 边（位置随玩家同步）
```

### P1-附：Player 入图专项 — ✅ 已完成（2026-02-17）

**设计决策（本次对话确定）：**

1. **节点类型**: `WorldNodeType.PLAYER`（保留独立类型，便于 `get_by_type(PLAYER)` 快速查找）
2. **State 结构**: 基于 `default_npc_state()` + player 专有字段（quests/discovered_locations/rest_state），与 NPC 共享 D&D 5e 角色卡
3. **权威源**: WorldGraph player 节点为运行时唯一权威源
4. **`PlayerCharacter` 模型**: 完全废弃，运行时所有读写走图节点
5. **节点 ID**: `"player"`
6. **边关系**: `MEMBER_OF(player → camp)`、`HOSTS(location → player)`

**构图阶段**（graph_builder.py Step 6 扩展）：
- 从角色创建数据初始化 player 节点 state
- 建立 MEMBER_OF 和 HOSTS 边

**连带影响：**
- `session.player` 引用全部替换为 `wg.get_node("player")`
- `mark_player_dirty()` → 由 snapshot 脏状态追踪替代
- `character_store.save_character()` / `get_character()` → 快照统一持久化
- 角色创建流程需后续调整（创建时直接写图节点）
- 前端 API 响应中 player 数据从图节点 state 构造

---

## 二、P2: ON_DISPOSITION 闭环

### 根因

**集成遗漏 bug**：`update_disposition` 工具调用旧的 `graph_store.update_disposition()` 写 Firestore 独立路径（`worlds/{world_id}/characters/{char_id}/dispositions/player`），不回写 WorldGraph NPC 节点的 `state.dispositions`。

引擎 tick 时读的是 `node.state.dispositions.player`（图内存态），两边数据永远不同步 → ON_DISPOSITION 行为基于初始数据评估，**形同虚设**。

### 解决方案

1. `update_disposition` 工具 → 直接写图节点: `wg.merge_state(npc_id, {"dispositions": {"player": updated_values}})`
2. 删除工具中对 `graph_store.update_disposition()` 的调用
3. 好感度 clamp 逻辑（-100~100 等）保留在工具层
4. `graph_store.update_disposition()` / `get_disposition()` 标记为**待清理旧逻辑**

### 阈值越界问题（暂不处理）

`_matches_disposition_filter()` 做当前值比较 + `once=True` 对 90% 场景够用。极端场景（反复越界触发）当前无实际数据需求，留到需要时再加前值比较。

### 待办

- 专项清理 `graph_store` 中不再被运行时消费的旧 Firestore 路径

---

## 三、P3: ON_TIME 时间驱动

### 现状评估

**引擎侧基本完备**，不需要修改：
- `_matches_time_filter()` (behavior_engine.py:963-1002) 支持 `hour_gte/lte`、`day_gte/lte`
- **已支持跨午夜**（line 988-990: `hour_gte > hour_lte` 时用 OR 逻辑）
- 每 tick 自动收集 ON_TIME behaviors（line 565）

### 已知限制（不阻塞，未来处理）

**时间跳跃盲区**：
- 场景：玩家 22:00 休息 → 时间跳到 06:00 → 午夜事件（hour_gte:0, hour_lte:2）被跳过
- 原因：tick 驱动的固有局限，时间大幅跳跃时中间时段的 ON_TIME 行为不触发
- 方案：时间跳跃时模拟中间 tick — 留到 NPC 日程系统（U16）时一并解决

### 定调

- **不改** — 引擎侧无 bug
- **标记 U16**: NPC 日程系统（`schedule_table` → ON_TIME Behavior 转换）待做
- **标记**: 时间跳跃盲区 — 未来做日程系统时一并处理
- 低优先补测试（等有实际 ON_TIME 数据时）

---

## 四、P4: scope 与 global 传播区分度

### 根因

`_get_propagation_targets()` (event_propagation.py:123-159) 对 scope 和 global 使用**完全相同**的逻辑，不符合设计定义。

### 设计意图 vs 实际行为

| visibility | 设计定义 (models.py:341) | 实际行为 | 偏差 |
|-----------|------------------------|---------|------|
| `local` | 仅本节点 | 不传播 ✅ | 正确 |
| `scope` | 沿 CONTAINS 边向上/向下 | 向上/向下 **+ CONNECTS 水平扩散** | **多做了** — 不该水平传播 |
| `global` | 全图 | 向上/向下 + 水平，**MAX_DEPTH=3** | **做少了** — 3 跳不够覆盖全图 |

世界图完整路径 `location → area → region → world_root → region2 → area2 → location2` = 6 跳，MAX_DEPTH=3 只能到 world_root。

### 解决方案

1. **scope 修正**: `_get_propagation_targets()` 中，`visibility == "scope"` 时**去掉** CONNECTS 水平传播，只保留 CONTAINS 垂直 + 实体

```python
# 修改 line 152-157:
# scope: 仅垂直传播（CONTAINS 上下 + 实体）
# global: 垂直 + 水平 CONNECTS
if visibility == "global":
    for neighbor_id, _ in self.wg.get_neighbors(node_id, WorldEdgeType.CONNECTS.value):
        targets.append((neighbor_id, "horizontal"))
# scope 不加 CONNECTS 水平传播
```

2. **global MAX_DEPTH**: 提升到 **8**（覆盖 6 层完整路径 + 2 层余量）

```python
# 新增 line 41 附近:
MAX_DEPTH_DEFAULT = 3    # scope 默认深度
MAX_DEPTH_GLOBAL = 8     # global 覆盖全图
```

3. 代码加注释说明 scope vs global 的语义区别
4. 文档同步更新

---

## 五、P5: region 元数据

### 根因

**纯数据层问题**，设计和代码无缺陷。

region 节点由 `graph_builder.py:400-408` 从 `area.region` 字段自动聚合，`properties={}` 为空是因为源数据中没有 region 级别的独立描述数据。

### 定调

- **不改代码** — 归入管线升级（Sprint 4 P1-P3）统一处理
- 构图代码加注释: `# region properties 待管线补充（description/danger_level/lore）`
- 能力矩阵文档标注: 数据层问题，管线阶段解决

---

## 六、P6: 战斗融合 — ✅ 已完成（2026-02-17）

### 根因

战斗结束后，结果同步走旧的 Firestore 路径（`character_store.save_character()`），不写图节点，也不发射 WorldEvent。

### 当前战斗结束数据流

```
combat_state.is_ended = True
  → resolve_combat_session_v3 (MCP)
  → sync_combat_result_to_character:
      character.current_hp = hp_remaining      ← 写 session.player（旧路径）
      character_service.add_xp(xp)             ← 写 Firestore（旧路径）
      character.gold += gold                   ← 写 session.player（旧路径）
      character_store.save_character()          ← 持久化到 Firestore（旧路径）
  → game_state.combat_id = None

  ❌ 无 WorldEvent 发射
  ❌ 敌人 NPC 状态不更新
  ❌ 玩家状态不写图
```

### 解决方案

**第一层（跟随 Player 入图）**：
- `sync_combat_result_to_character` → 改为写 player 图节点 state
- `wg.merge_state("player", {"hp": remaining, "xp": new_xp, "gold": new_gold})`
- 废弃 `character_store.save_character()` 旧路径

**第二层（战斗事件回写）**：
- 战斗结束后发射 WorldEvent:
  ```python
  WorldEvent(
      event_type="combat_ended",
      origin_node=player_location,
      data={"result": "victory/defeat", "enemies": [...], "rewards": {...}},
      visibility="scope",  # 战斗影响当前区域
  )
  ```
- 行为引擎可响应（如"击败 BOSS → 解锁新区域"通过 ON_EVENT 行为实现）

**第三层（敌人不回写）**：
- 敌人是 LLM 根据地图信息生成的临时怪物，不存在于图中
- 如果未来有命名 BOSS 作为图中 NPC 节点参战，再按需扩展

---

## 七、P7: 副作用奖励类型覆盖 — ✅ 已完成（2026-02-17）

### 根因

`_apply_tick_side_effects()` (session_runtime.py:456-483) 仅处理 2/6 种副作用类型，且写入旧的 `session.player` 路径。

### 当前覆盖

| 事件类型 | 当前处理 | 写入目标 |
|---------|---------|---------|
| `xp_awarded` | ✅ | `session.player.xp` ← 旧路径 |
| `item_granted` | ✅ | `session.player.inventory` ← 旧路径 |
| `gold_awarded` | ❌ 缺失 | — |
| `reputation_changed` | ❌ 缺失 | — |
| `world_flag_set` | ❌ 缺失 | — |
| `unlock_events` | ✅ BehaviorEngine 级联 | 不需要副作用处理 |

### 解决方案

全部改为写图节点（跟随 Player 入图）：

```python
# 写 player 图节点 state
"xp_awarded"         → wg.merge_state("player", {"xp": current + amount})
"item_granted"       → wg.merge_state("player", {"inventory": [..., new_item]})
"gold_awarded"       → wg.merge_state("player", {"gold": current + amount})

# 写 world_root 图节点 state
"reputation_changed" → wg.merge_state("world_root", {"faction_reputations": {faction: new_val}})
"world_flag_set"     → wg.merge_state("world_root", {"world_flags": {key: value}})
```

### 物品系统决策

**当前**（P7 阶段）：方案 A — inventory 作为 player 节点 state 中的列表，不阻塞当前改动

**待办专项**：方案 B — 物品图化
- 每个物品实例为独立节点，通过 HAS_ITEM 边连接持有者（player/NPC/location）
- 支持物品行为（诅咒武器 ON_TICK 扣血）、场景拾取（location → item）、物品转移（边删旧加新）
- 需要独立设计：quantity 建模、物品模板 vs 实例、loot_containers
- 完成后迁移 player.state.inventory → HAS_ITEM 边

---

## 八、P8: 导航基础区域移动

### 根因

`navigate()` 从旧的 `self.area.definition.connections`（AreaConnection 静态模型）读连接信息，不从 WorldGraph 的 CONNECTS 边读。这是"双轨数据源"问题的具体表现。

### 当前 navigate() 连接检查

```python
# v4_agentic_tools.py:345-354 — 从旧模型读
for conn in self.area.definition.connections:   # ← AreaConnection 静态列表
    if conn.target_area_id == area_id:
        connection = conn
        break
```

### CONNECTS 边当前属性

graph_builder.py:479-487 构图时存储的边属性：

| 属性 | 已存储 | 来源 |
|------|--------|------|
| `connection_type` | ✅ | AreaConnection.connection_type |
| `travel_time` | ✅ | AreaConnection.travel_time |
| `requirements` | ✅ | AreaConnection.requirements |
| `description` | ❌ 未传递 | AreaConnection 有此字段但构图时遗漏 |
| `blocked` | ❌ | 设计规格有，源数据无 |
| `danger` | ❌ | 设计规格有，源数据无 |
| `encounter_chance` | ❌ | 设计规格有，源数据无 |
| `travel_time_hours` | ❌ | 设计规格有，源数据无 |

### 解决方案

1. **navigate() 从图读 CONNECTS 边**:
   ```python
   # 替代 self.area.definition.connections
   neighbors = wg.get_neighbors(current_area, WorldEdgeType.CONNECTS.value)
   for target_id, edge_props in neighbors:
       if target_id == area_id:
           connection = edge_props
           break
   ```

2. **构图补全**: `description` 字段传递到 CONNECTS 边（当前遗漏）

3. **检查骨架**（代码就位，等数据填充）:
   ```python
   if edge_props.get("blocked"):
       return {"success": False, "error": f"道路被封锁: {edge_props.get('blocked_reason', '')}"}

   encounter_chance = edge_props.get("encounter_chance", 0)
   if encounter_chance > 0 and random.random() < encounter_chance:
       # 触发遭遇事件
   ```

4. **不需要扩展 AreaConnection 模型** — 新属性直接放 CONNECTS 边 properties，由管线或行为引擎在运行时修改

5. **行为引擎动态封路**: 引擎可通过 `CHANGE_STATE` 修改 CONNECTS 边属性（如"触发事件后封锁道路"），navigate() 从图读自然能看到

6. **数据填充**: CONNECTS 边的 blocked/danger/encounter_chance 由管线阶段补充

---

## 九、跨 P 项共性改动清单

### 9.1 待清理旧代码

| 旧代码 | 位置 | 替代方案 | 关联 P |
|--------|------|---------|--------|
| `graph_store.update_disposition()` | graph_store.py:228 | 写 NPC 图节点 state | P2 |
| `graph_store.get_disposition()` | graph_store.py:212 | 从 NPC 图节点 state 读 | P2 |
| `character_store.save_character()` | character_store.py | ✅ persist() 已不再调用（U2） | P1, P6, P7 |
| `character_store.get_character()` | character_store.py | 仍用于初始 seed 加载（设计如此） | P1, P6 |
| `session.player` 直接引用 | session_runtime.py 全文 | ✅ 已返回 PlayerNodeView（U2）；P7 副作用通过 view 写图 | P1, P7 |
| `self.area.definition.connections` | v4_agentic_tools.py:346 | ✅ 从 CONNECTS 边读（P8） | P8 |
| `world.area_registry` 运行时引用 | v4_agentic_tools.py:436-444 | 从图查询 | P8 |
| `world.character_registry` 运行时引用 | context_assembler.py:232 | 从图查 NPC 节点 | 全局 |
| `sync_combat_result_to_character()` | flash_cpu_service.py:1631 | ✅ 新增 session 参数 → 图路径（U2），旧路径保留兼容 | P6 |

### 9.2 待做专项（不在本轮 P1-P8 范围）

| 专项 | 说明 | 优先级 |
|------|------|--------|
| U16 NPC 日程系统 | `schedule_table` → ON_TIME Behavior | 低（Sprint 5） |
| 物品图化 | HAS_ITEM 边 + 物品节点 + loot_containers | 中（独立设计） |
| 时间跳跃中间 tick | 大幅时间推进时模拟中间时段 | 低（随 U16） |
| 角色创建流程改造 | 创建时直接写图节点，废弃 character_store 创建路径 | 高（Player 入图 ✅ 已完成，创建流程待后续调整） |
| 旧代码清理专项 | 统一清理上表中的过时路径 | 中 |

---

## 十、依赖图与执行顺序

```
Player 入图（P1-附）✅ 已完成
  ├─→ P1: navigate 调 handle_enter/exit + HOSTS 边更新 ✅ 已完成
  ├─→ P6: 战斗结果写 player 图节点 + WorldEvent 发射 ✅ 已完成
  ├─→ P7: 副作用 6 种全覆盖 + 去重修复 ✅ 已完成
  └─→ 旧 PlayerCharacter/character_store 清理

P2: update_disposition 写图节点 ✅ 已完成
P4: scope/global 传播语义修正 ✅ 已完成
P8: navigate 从图读 CONNECTS 边 ✅ 已完成
  └─→ P8 检查骨架: blocked/encounter（等管线数据）
P12: 枚举替换裸字符串 ✅ 已完成

P3: 不改（引擎已完备）
P5: 不改（管线阶段补数据）
```

**执行顺序**：

```
第一步（基础设施）: ✅ 全部完成
  Player 入图 ✅ + P2(disposition回写) ✅ + P4(传播修正) ✅ + P8(从图读CONNECTS) ✅ + P12(枚举) ✅

第二步（功能闭环）: ✅ 全部完成
  P1(enter/exit) ✅ + P6(战斗事件) ✅ + P7(副作用补全) ✅
  测试: test_p1_p6_integration.py (15 tests) + test_p7_side_effects.py (12 tests)

第三步（清理）: 旧代码清理专项
  → 确认新路径稳定后，移除旧路径

剩余 P 项: P9/P11（依赖 U17）
```

---

## 十一、验证标准

### 功能验证

| 验证项 | 预期行为 |
|--------|---------|
| navigate 后 ON_ENTER 触发 | 进入有 ON_ENTER behavior 的区域 → narrative_hints 出现 |
| navigate 后 ON_EXIT 触发 | 离开有 ON_EXIT behavior 的区域 → 事件发射 |
| disposition 变更可见 | `update_disposition` 后，下一 tick ON_DISPOSITION behavior 基于新值评估 |
| scope 事件不水平传播 | scope 事件不传播到 CONNECTS 相邻区域 |
| global 事件覆盖全图 | global 事件能到达 6 跳外的节点 |
| 战斗结束触发行为 | 击败特定敌人 → ON_EVENT("combat_ended") 行为触发 |
| 副作用 6 种全部可用 | xp/item/gold/reputation/world_flags/unlock 全部正确应用到图节点 |
| navigate 从图读连接 | 行为引擎修改 CONNECTS 边 blocked=true → navigate 拒绝通行 |
| Player 节点权威 | 所有玩家状态读写均通过 `wg.get_node("player")` / `wg.merge_state("player", ...)` |

### 回归验证

- 现有 196 个测试全部通过
- 新增 P1-P8 相关测试用例
- 快照恢复后图状态一致性
